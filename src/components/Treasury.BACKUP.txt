import React, { useState, useEffect, useCallback } from 'react';
import { 
  Box, Paper, Typography, Tabs, Tab, Button, TextField, Dialog,
  DialogTitle, DialogContent, DialogActions, Grid, CircularProgress,
  Snackbar, Alert, AlertTitle, IconButton, TablePagination,
  Autocomplete, Card, CardContent,
  Divider, Chip, Stack, Tooltip, Avatar,
  Grow, Slide, InputAdornment
} from '@mui/material';
import { DataGrid, GridRenderCellParams, GridToolbar } from '@mui/x-data-grid';
import { styled } from '@mui/material/styles';
import SearchIcon from '@mui/icons-material/Search';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
import PaymentIcon from '@mui/icons-material/Payment';
import ReceiptIcon from '@mui/icons-material/Receipt';
import PersonIcon from '@mui/icons-material/Person';
import AttachMoneyIcon from '@mui/icons-material/AttachMoney';
import AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';
import WalletIcon from '@mui/icons-material/Wallet';
import MoneyOffIcon from '@mui/icons-material/MoneyOff';
import MoneyIcon from '@mui/icons-material/Money';
import FilterListIcon from '@mui/icons-material/FilterList';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import WarningIcon from '@mui/icons-material/Warning';

import { useSnackbar } from 'notistack';
import { ClientsAPI,SuppliersAPI, SettingsAPI, TreasuryAPI, SalesAPI, AccountsAPI, InventoryAPI } from '../services/api/index';
import { Client, Account, ClientDeposit, TabPanelProps, OutstandingSale, OutstandingSupply, AccountStatement, ActualClientBalanceResponse,ActualSupplierBalanceResponse, Supplier } from '../interfaces/business';
import PermissionGuard from './PermissionGuard';
import { 
  formatCurrency, 
  formatDate, 
  getPaymentStatusColor, 
  getPaymentStatusLabel,
  mapStatementsForGrid,
  getTransactionTypeChipStyles,
  validateDepositForm,
  getTransactionTypeColor
} from '../utils/treasuryUtils';

import { 
  validateDecimalInput, 
  formatNumberDisplay, 
  getValidationError,
  validateAmountInput
} from '../utils/inputValidation';

// Styled components for better visuals
const StyledPaper = styled(Paper)(() => ({
  borderRadius: 12,
  boxShadow: '0 4px 12px 0 rgba(0,0,0,0.05)',
  overflow: 'hidden',
}));

const ClientInfoCard = styled(Card)(() => ({
  borderRadius: 12,
  transition: 'transform 0.2s',
  '&:hover': {
    transform: 'translateY(-4px)',
    boxShadow: '0 12px 20px rgba(0,0,0,0.1)',
  },
}));

// Helper function to safely parse balance values that might be strings or numbers
const parseBalance = (value: string | number | undefined | null): number => {
  if (value === undefined || value === null) return 0;
  if (typeof value === 'number') return value;
  return parseFloat(value) || 0;
};

function TransactionsTabs({ clientBalanceData }) {
  const [tab, setTab] = useState(0);
  const mapStatementsForJournal = (statements: AccountStatement[]) =>
  statements.map((tx, index) => ({
    id: index,
    date: tx.date,
    libelle: tx.transaction_type === "sale" ? "Vente de marchandises" : "Paiement",
    debit: tx.transaction_type === "sale" ? parseFloat(tx.debit as string) : 0,
    credit: tx.transaction_type === "cash_receipt" ? parseFloat(tx.credit as string) : 0,
    solde: parseFloat(tx.balance as string),
  }));
  return (
    <Paper sx={{ mb: 3, overflow: 'hidden' }} elevation={2}>
      {/* Onglets */}
      <Box sx={{ borderBottom: 1, borderColor: 'divider', bgcolor: 'primary.light' }}>
        <Tabs
          value={tab}
          onChange={(_, newValue) => setTab(newValue)}
          textColor="inherit"
          indicatorColor="secondary"
        >
          <Tab 
            label={`Journal Caisse Client (${mapStatementsForJournal(clientBalanceData.statements)?.length || 0})`} 
            sx={{ color: 'primary.contrastText' }} 
          />
          <Tab 
            label={`Historique des transactions (${clientBalanceData.statements?.length || 0})`} 
            sx={{ color: 'primary.contrastText' }} 
          />
          
        </Tabs>
      </Box>

      {/* Contenu selon l'onglet */}
      <Box sx={{ 
        height: Math.min(Math.max(350, (clientBalanceData.statements?.length || 0) * 55 + 180), 400), 
        width: '100%' 
      }}>
        {tab === 0 ? (
          // 👉 Nouveau tableau (Journal Caisse Client)
         
           <DataGrid
            rows={mapStatementsForJournal(clientBalanceData.statements)}
            columns={[
              { field: 'date', headerName: 'Date', width: 120 },
              { field: 'libelle', headerName: 'Libellé', flex: 1, minWidth: 200 },
              { 
                field: 'debit', 
                headerName: 'Débit', 
                width: 150, 
                align: 'right', 
                headerAlign: 'right',
                renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : ""
              },
              { 
                field: 'credit', 
                headerName: 'Crédit', 
                width: 150,
                align: 'right', 
                headerAlign: 'right',
                renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : ""
              },
              { 
                field: 'solde', 
                headerName: 'Solde', 
                width: 160,
                align: 'right', 
                headerAlign: 'right',
                renderCell: (params) => `${formatCurrency(params.value)}`
              },
            ]}
            getRowClassName={(params) => params.indexRelativeToCurrentPage % 2 === 0 ? '' : 'even-row' } 
            initialState={{ pagination: { paginationModel: { pageSize: 10, page: 0 }, }, sorting: { sortModel: [{ field: 'rawDate', sort: 'desc' }], }, }} 
            density="compact" disableRowSelectionOnClick slots={{ toolbar: GridToolbar, }} 
            slotProps={{ toolbar: { showQuickFilter: true, quickFilterProps: { debounceMs: 300 }, }, }} 
            sx={{ border: 'none', '& .MuiDataGrid-cell:focus': { outline: 'none', }, '& .even-row': { bgcolor: 'rgba(0, 0, 0, 0.02)', }, '& .MuiDataGrid-columnHeaders': { backgroundColor: 'rgba(0, 0, 0, 0.03)', borderRadius: 0, } }}
            pageSizeOptions={[5, 10, 25, 50]}

          />
        ) : (
          // 👉 Ton tableau existant (Historique)

          <DataGrid
            rows={mapStatementsForGrid(clientBalanceData.statements)}
            columns={[
              { field: 'date', headerName: 'Date', width: 120 },
              { field: 'reference', headerName: 'Référence', width: 140 },
              { field: 'type', headerName: 'Type', width: 180, renderCell: (params: GridRenderCellParams) => { const value = params.value || ''; return ( <Chip label={value} size="small" sx={getTransactionTypeChipStyles(value)} /> ); }  },
              { field: 'description', headerName: 'Description', flex: 1, minWidth: 200 },
              { field: 'debit', headerName: 'Débit', width: 130, align: 'right', renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : "" },
              { field: 'credit', headerName: 'Crédit', width: 130, align: 'right', renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : "" },
              { field: 'balance', headerName: 'Solde', width: 140, align: 'right', renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : "" },
            ]}
            getRowClassName={(params) => params.indexRelativeToCurrentPage % 2 === 0 ? '' : 'even-row' } 
            initialState={{ pagination: { paginationModel: { pageSize: 10, page: 0 }, }, sorting: { sortModel: [{ field: 'rawDate', sort: 'desc' }], }, }} 
            density="compact" disableRowSelectionOnClick slots={{ toolbar: GridToolbar, }} 
            slotProps={{ toolbar: { showQuickFilter: true, quickFilterProps: { debounceMs: 300 }, }, }} 
            sx={{ border: 'none', '& .MuiDataGrid-cell:focus': { outline: 'none', }, '& .even-row': { bgcolor: 'rgba(0, 0, 0, 0.02)', }, '& .MuiDataGrid-columnHeaders': { backgroundColor: 'rgba(0, 0, 0, 0.03)', borderRadius: 0, } }}
            pageSizeOptions={[5, 10, 25, 50]}
          />
        )}
      </Box>
    </Paper>
  );
}

function SupplierTransactionsTabs({ supplierBalanceData }) {
  const [tab, setTab] = useState(0);
  const mapStatementsForJournal = (statements: AccountStatement[]) =>
    statements.map((tx, index) => ({
      id: index,
      date: tx.date,
      libelle: tx.transaction_type === "supply" ? "Approvisionnement" : "Paiement fournisseur",
      debit: tx.transaction_type === "supplier_cash_payment" ? parseFloat(tx.debit as string) : 0,
      credit: tx.transaction_type === "supply" ? parseFloat(tx.credit as string) : 0,
      solde: parseFloat(tx.balance as string),
    }));
  
  return (
    <Paper sx={{ mb: 3, overflow: 'hidden' }} elevation={2}>
      {/* Onglets */}
      <Box sx={{ borderBottom: 1, borderColor: 'divider', bgcolor: 'primary.light' }}>
        <Tabs
          value={tab}
          onChange={(_, newValue) => setTab(newValue)}
          textColor="inherit"
          indicatorColor="secondary"
        >
          <Tab 
            label={`Journal Caisse Fournisseur (${mapStatementsForJournal(supplierBalanceData.statements)?.length || 0})`} 
            sx={{ color: 'primary.contrastText' }} 
          />
          <Tab 
            label={`Historique des transactions (${supplierBalanceData.statements?.length || 0})`} 
            sx={{ color: 'primary.contrastText' }} 
          />
        </Tabs>
      </Box>

      {/* Contenu selon l'onglet */}
      <Box sx={{ 
        height: Math.min(Math.max(350, (supplierBalanceData.statements?.length || 0) * 55 + 180), 400), 
        width: '100%' 
      }}>
        {tab === 0 ? (
          // Journal Caisse Fournisseur
          <DataGrid
            rows={mapStatementsForJournal(supplierBalanceData.statements)}
            columns={[
              { field: 'date', headerName: 'Date', width: 120 },
              { field: 'libelle', headerName: 'Libellé', flex: 1, minWidth: 200 },
              { 
                field: 'debit', 
                headerName: 'Débit', 
                width: 150, 
                align: 'right', 
                headerAlign: 'right',
                renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : ""
              },
              { 
                field: 'credit', 
                headerName: 'Crédit', 
                width: 150,
                align: 'right', 
                headerAlign: 'right',
                renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : ""
              },
              { 
                field: 'solde', 
                headerName: 'Solde', 
                width: 160,
                align: 'right', 
                headerAlign: 'right',
                renderCell: (params) => `${formatCurrency(params.value)}`
              },
            ]}
            getRowClassName={(params) => params.indexRelativeToCurrentPage % 2 === 0 ? '' : 'even-row' } 
            initialState={{ pagination: { paginationModel: { pageSize: 10, page: 0 }, }, sorting: { sortModel: [{ field: 'rawDate', sort: 'desc' }], }, }} 
            density="compact" disableRowSelectionOnClick slots={{ toolbar: GridToolbar, }} 
            slotProps={{ toolbar: { showQuickFilter: true, quickFilterProps: { debounceMs: 300 }, }, }} 
            sx={{ border: 'none', '& .MuiDataGrid-cell:focus': { outline: 'none', }, '& .even-row': { bgcolor: 'rgba(0, 0, 0, 0.02)', }, '& .MuiDataGrid-columnHeaders': { backgroundColor: 'rgba(0, 0, 0, 0.03)', borderRadius: 0, } }}
            pageSizeOptions={[5, 10, 25, 50]}
          />
        ) : (
          // Historique des transactions
          <DataGrid
            rows={mapStatementsForGrid(supplierBalanceData.statements)}
            columns={[
              { field: 'date', headerName: 'Date', width: 120 },
              { field: 'reference', headerName: 'Référence', width: 140 },
              { field: 'type', headerName: 'Type', width: 180, renderCell: (params: GridRenderCellParams) => { const value = params.value || ''; return ( <Chip label={value} size="small" sx={getTransactionTypeChipStyles(value)} /> ); }  },
              { field: 'description', headerName: 'Description', flex: 1, minWidth: 200 },
              { field: 'debit', headerName: 'Débit', width: 130, align: 'right', renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : "" },
              { field: 'credit', headerName: 'Crédit', width: 130, align: 'right', renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : "" },
              { field: 'balance', headerName: 'Solde', width: 140, align: 'right', renderCell: (params) => params.value > 0 ? `${formatCurrency(params.value)}` : "" },
            ]}
            getRowClassName={(params) => params.indexRelativeToCurrentPage % 2 === 0 ? '' : 'even-row' } 
            initialState={{ pagination: { paginationModel: { pageSize: 10, page: 0 }, }, sorting: { sortModel: [{ field: 'rawDate', sort: 'desc' }], }, }} 
            density="compact" disableRowSelectionOnClick slots={{ toolbar: GridToolbar, }} 
            slotProps={{ toolbar: { showQuickFilter: true, quickFilterProps: { debounceMs: 300 }, }, }} 
            sx={{ border: 'none', '& .MuiDataGrid-cell:focus': { outline: 'none', }, '& .even-row': { bgcolor: 'rgba(0, 0, 0, 0.02)', }, '& .MuiDataGrid-columnHeaders': { backgroundColor: 'rgba(0, 0, 0, 0.03)', borderRadius: 0, } }}
            pageSizeOptions={[5, 10, 25, 50]}
          />
        )}
      </Box>
    </Paper>
  );
}

function AccountMovementsTabs({ accountMovements, loadingMovements, allAccounts }) {
  const [tab, setTab] = useState(0);

  // Exemple: transformation pour Journal Caisse
  const mapMovementsForJournal = (movements: AccountStatement[]) =>
    movements.map((m, index) => ({
      id: index,
      date: m.date,
      libelle: m.transaction_type === "sale" ? "Vente de marchandises" : "Paiement",
      debit: m.transaction_type === "sale" ? parseFloat(m.debit as string) : 0,
      credit: m.transaction_type === "cash_receipt" ? parseFloat(m.credit as string) : 0,
      solde: parseFloat(m.balance as string),
    }));

  return (
    <Paper sx={{ width: '100%' }} elevation={2}>
      {/* Onglets */}
      <Box sx={{ borderBottom: 1, borderColor: 'divider', bgcolor: 'primary.light', px: 2 }}>
        <Tabs
          value={tab}
          onChange={(_, newValue) => setTab(newValue)}
          textColor="inherit"
          indicatorColor="secondary"
        >
          <Tab 
            label={`Journal Caisse Client (${mapMovementsForJournal(accountMovements).length})`} 
            sx={{ color: 'primary.contrastText' }} 
          />
          <Tab 
            label={`Mouvements (${accountMovements.length})`} 
            sx={{ color: 'primary.contrastText' }} 
          />
          
        </Tabs>
      </Box>

      {/* Contenu */}
      <Box
        sx={{
          height: Math.min(Math.max(400, accountMovements.length * 55 + 200), 800),
          width: '100%',
        }}
      >
        {loadingMovements ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
            <CircularProgress />
          </Box>
        ) : accountMovements.length > 0 ? (
          tab === 0 ? (
            // 👉 Nouveau tableau : Journal Caisse
           
            <DataGrid
              rows={mapMovementsForJournal(accountMovements)}
              columns={[
                { field: 'date', headerName: 'Date', width: 120 },
                { field: 'libelle', headerName: 'Libellé', flex: 1, minWidth: 200 },
                { field: 'debit', headerName: 'Débit', width: 150, align: 'right', renderCell: (params) => params.value > 0 ? formatCurrency(params.value) : null },
                { field: 'credit', headerName: 'Crédit', width: 150, align: 'right', renderCell: (params) => params.value > 0 ? formatCurrency(params.value) : null },
                { field: 'solde', headerName: 'Solde', width: 160, align: 'right', renderCell: (params) => formatCurrency(params.value) },
              ]}
              density="compact"
              disableRowSelectionOnClick
              slots={{ toolbar: GridToolbar }}
            />
          ) : (
            // 👉 Tableau existant : Mouvements

             <DataGrid
              rows={accountMovements.map(movement => ({
                id: movement.id,
                account_name: allAccounts.find(a => a.id === Number(movement.account))?.name || 'N/A',
                date: formatDate(movement.date),
                rawDate: movement.date,
                reference: movement.reference,
                transaction_type_display: movement.transaction_type_display,
                transaction_type: movement.transaction_type,
                description: movement.description,
                debit: movement.debit,
                credit: movement.credit,
                balance: movement.balance
              }))}
              columns={[
                { field: 'date', headerName: 'Date', width: 120 },
                { field: 'account_name', headerName: 'Compte', width: 150 },
                { field: 'reference', headerName: 'Référence', width: 140 },
                { field: 'transaction_type_display', headerName: 'Type', width: 180,  
                          renderCell: (params) => ( <Chip label={params.value} size="small" 
                          color={getTransactionTypeColor(params.row.transaction_type)} sx={{ fontWeight: 500 }} /> ) },
                { field: 'description', headerName: 'Description', flex: 1, minWidth: 200 },
                { field: 'debit', headerName: 'Débit', width: 130, align: 'right', renderCell: (params) => params.value > 0 ? formatCurrency(params.value) : null },
                { field: 'credit', headerName: 'Crédit', width: 130, align: 'right', renderCell: (params) => params.value > 0 ? formatCurrency(params.value) : null },
                { field: 'balance', headerName: 'Solde', width: 140, align: 'right', renderCell: (params) => formatCurrency(params.value) },
              ]}
              density="compact"
              disableRowSelectionOnClick
              slots={{ toolbar: GridToolbar }}
            />
          )
        ) : (
          <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100%' }}>
            <MoneyOffIcon sx={{ fontSize: 60, color: 'text.secondary', mb: 2 }} />
            <Typography variant="h6" color="text.secondary" gutterBottom>
              Aucun mouvement trouvé
            </Typography>
  
          </Box>
        )}
      </Box>
    </Paper>
  );
}
function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`treasury-tabpanel-${index}`}
      aria-labelledby={`treasury-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box p={3}>
          {children}
        </Box>
      )}
    </div>
  );
}

function a11yProps(index: number) {
  return {
    id: `treasury-tab-${index}`,
    'aria-controls': `treasury-tabpanel-${index}`,
  };
}

const Treasury = () => {

  const [tabValue, setTabValue] = useState(0);
  // Client account management state
  const [clients, setClients] = useState<Client[]>([]);
  const [suppliers, setSuppliers] = useState<Supplier[]>([]);
  const [selectedClient, setSelectedClient] = useState<Client | null>(null);
  const [selectedSupplier, setSelectedSupplier] = useState<Supplier | null>(null);
  const [clientBalanceData, setClientBalanceData] = useState<ActualClientBalanceResponse | null>(null);
  const [supplierBalanceData, setSupplierBalanceData] = useState<ActualSupplierBalanceResponse | null>(null);

  const [loadingClientData, setLoadingClientData] = useState(false);
  const [loadingSupplierData, setLoadingSupplierData] = useState(false);
  const [clientSearch, setClientSearch] = useState('');
  const [supplierSearch, setSupplierSearch] = useState('');
  // Add client pagination state
  const [clientPage, setClientPage] = useState(0);
  const [supplierPage, setSupplierPage] = useState(0);
  const [clientRowsPerPage, setClientRowsPerPage] = useState(6);
  const [supplierRowsPerPage, setSupplierRowsPerPage] = useState(6);

  // Payment related state variables
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [selectedSaleForPayment, setSelectedSaleForPayment] = useState<OutstandingSale | null>(null);
  const [paymentAmount, setPaymentAmount] = useState(0);
  const [paymentDescription, setPaymentDescription] = useState('');
  const [processingPayment, setProcessingPayment] = useState(false);

  // Supplier payment state variables
  const [showSupplierPaymentModal, setShowSupplierPaymentModal] = useState(false);
  const [selectedSupplyForPayment, setSelectedSupplyForPayment] = useState<OutstandingSupply | null>(null);
  const [supplierPaymentAmount, setSupplierPaymentAmount] = useState(0);
  const [supplierPaymentDescription, setSupplierPaymentDescription] = useState('');
  const [processingSupplierPayment, setProcessingSupplierPayment] = useState(false);
  const [selectedSupplierCompanyAccount, setSelectedSupplierCompanyAccount] = useState<Account | null>(null);

  // New state for company account selection in payment
  const [selectedCompanyAccount, setSelectedCompanyAccount] = useState<Account | null>(null);
  const [companyAccountError, setCompanyAccountError] = useState<string | null>(null);
  const [companyAccountTouched, setCompanyAccountTouched] = useState(false);
  const companyAccountRequired = true;

  // New client deposit state
  const [showDepositModal, setShowDepositModal] = useState(false);
  const [newDeposit, setNewDeposit] = useState<ClientDeposit>({
    client: null,
    account: null,
    amount: 0,
    payment_method: null,
    date: new Date().toISOString().split('T')[0],
    description: 'Dépôt sur compte'
  });

  // Resources needed for forms
  const [accounts, setAccounts] = useState<Account[]>([]);
  const [paymentMethods, setPaymentMethods] = useState<Array<{id: number, name: string}>>([]);
  const [loadingResources, setLoadingResources] = useState(false);
  // Add state for balance change feedback
  const [previousBalance, setPreviousBalance] = useState<number | null>(null);
  const [balanceChangeHighlight, setBalanceChangeHighlight] = useState(false);

  // Account movements state
  const [accountMovements, setAccountMovements] = useState<AccountStatement[]>([]);
  const [loadingMovements, setLoadingMovements] = useState(false);
  const [selectedAccount, setSelectedAccount] = useState<Account | null>(null);
  const [allAccounts, setAllAccounts] = useState<Account[]>([]);
  const [transactionTypeFilter, setTransactionTypeFilter] = useState<string>('');
  const [startDate, setStartDate] = useState<string>('');  const [endDate, setEndDate] = useState<string>('');
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [showSuccessSnackbar, setShowSuccessSnackbar] = useState(false);
  
  // Use notistack hook for notifications
  const { enqueueSnackbar } = useSnackbar();
  
  // Account movements functions
  const fetchAllAccounts = useCallback(async () => {
    try {
      const data = await AccountsAPI.getAll();
      setAllAccounts(data);
    } catch (err) {
      console.error('Error fetching accounts:', err);
      setError('Erreur lors du chargement des comptes.');
    }
  }, []);

  const fetchAccountMovements = useCallback(async () => {
    try {
      setLoadingMovements(true);
      setError(null);
      
      // Build query parameters
      const params = new URLSearchParams();
      if (selectedAccount) {
        params.append('account', selectedAccount.id.toString());
      }
      if (startDate) {
        params.append('start_date', startDate);
      }
      if (endDate) {
        params.append('end_date', endDate);
      }
      if (transactionTypeFilter) {
        params.append('transaction_type', transactionTypeFilter);
      }

      // Call the API
      let data: AccountStatement[] = [];
      if (selectedAccount) {
        data = await TreasuryAPI.getAccountStatements(selectedAccount.id) as AccountStatement[];
      } else {
        data = await TreasuryAPI.getAccountStatements() as AccountStatement[];
      }
      
      setAccountMovements(data);
    } catch (err) {
      console.error('Error fetching account movements:', err);
      setError('Erreur lors du chargement des mouvements de compte.');
      setAccountMovements([]);    } finally {
      setLoadingMovements(false);
    }
  }, [selectedAccount, startDate, endDate, transactionTypeFilter]);


  // Grouped useEffect for all data/resource loading
  useEffect(() => {
    // Initial client fetch
    fetchClients();
    fetchSuppliers();
    fetchAllAccounts();


    // Deposit modal resource fetch
    if (showDepositModal) {
      fetchResources();
    }

    // Company accounts tab fetch
    if (tabValue === 2) {
      fetchAllAccounts();
    }

    // Account movements tab fetch
    if (tabValue === 3) {
      fetchAccountMovements();
    }
  }, [showDepositModal, tabValue, fetchAllAccounts, fetchAccountMovements]);

  // Filter clients for client tab
  const filteredClients = clients.filter((client) =>
    client.name.toLowerCase().includes(clientSearch.toLowerCase()) ||
    (client.contact_person && client.contact_person.toLowerCase().includes(clientSearch.toLowerCase()))
  );

  const filteredSuppliers = suppliers.filter((supplier) =>
    supplier.name.toLowerCase().includes(supplierSearch.toLowerCase()) ||
    (supplier.contact_person && supplier.contact_person.toLowerCase().includes(supplierSearch.toLowerCase()))
  );

  // Get paginated client list
  const paginatedClients = filteredClients
    .slice(clientPage * clientRowsPerPage, clientPage * clientRowsPerPage + clientRowsPerPage);

  // Get paginated supplier list
  const paginatedSuppliers = filteredSuppliers
    .slice(supplierPage * supplierRowsPerPage, supplierPage * supplierRowsPerPage + supplierRowsPerPage);

  // Fetch clients from API
  const fetchClients = async () => {
    try {
      const data = await ClientsAPI.getAll();
      setClients(data);
    } catch (err) {
      console.error('Error fetching clients:', err);
      setError('Erreur lors du chargement des clients. Veuillez réessayer plus tard.');
    }
  };

  // Fetch suppliers from API
  const fetchSuppliers = async () => {
    try {
      const data = await SuppliersAPI.getAll();
      setSuppliers(data);
    } catch (err) {
      console.error('Error fetching suppliers:', err);
      setError('Erreur lors du chargement des fournisseurs. Veuillez réessayer plus tard.');
    }
  };

  // Fetch resources (accounts and payment methods)
  const fetchResources = async () => {
    try {
      setLoadingResources(true);
      const [accountsData, paymentMethodsData] = await Promise.all([
        TreasuryAPI.getAccounts(),
        SettingsAPI.getSettings('payment-methods')
      ]);
      setAccounts(accountsData);
      setPaymentMethods(paymentMethodsData);
      setLoadingResources(false);
    } catch (err) {
      console.error('Error loading resources:', err);
      setError('Erreur lors du chargement des comptes et méthodes de paiement.');
      setLoadingResources(false);
    }
  };

  // Handle tab change
  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
    // Clear any errors when switching tabs
    setError(null);
  };

  // Handle payment from client account
  const handlePayFromAccount = async (): Promise<void> => {
    if (!selectedSaleForPayment || !selectedClient) return;
    if (companyAccountRequired && !selectedCompanyAccount) {
      setCompanyAccountTouched(true);
      setCompanyAccountError('Veuillez sélectionner le compte de l’entreprise à créditer.');
      return;
    }
    try {
      setProcessingPayment(true);
      setError(null);
      setCompanyAccountError(null);
      // Check if this will be a credit payment
      const isCreditPayment = clientBalanceData && clientBalanceData.balance < paymentAmount;
      if (isCreditPayment) {
        const creditAmount = clientBalanceData 
          ? Math.abs(clientBalanceData.balance - paymentAmount)
          : paymentAmount;
        if (!window.confirm(`ATTENTION: Ce paiement dépassera le solde disponible du client et créera un crédit de ${formatCurrency(creditAmount)}. Voulez-vous continuer?`)) {
          setProcessingPayment(false);
          return;
        }
      }
      // Pay directly from account, now with company account
      interface EnhancedPaymentResponse {
        success: boolean;
        message: string;
        payment: {
          id: number;
          reference: string;
          amount: number;
          date: string;
        };
        sale: {
          id: number;
          reference: string;
          payment_status: string;
          workflow_state: string;
          status: string;
          total_amount: number;
          paid_amount: number;
          remaining_amount: number;
        };
        client_balance: number;
        is_credit_payment: boolean;
      }
      const response = await SalesAPI.payFromAccount(
        selectedSaleForPayment.id,
        { 
          amount: paymentAmount,
          description: paymentDescription || `Paiement pour la vente ${selectedSaleForPayment.reference} depuis le compte client`,
          company_account: selectedCompanyAccount?.id || null
        }
      ) as EnhancedPaymentResponse;
      let successMsg = `Paiement de ${formatCurrency(response.payment.amount)} traité avec succès. Nouveau solde client: ${formatCurrency(response.client_balance)}`;
      if (response.is_credit_payment) {
        successMsg = `⚠️ PAIEMENT À CRÉDIT: ${successMsg}`;
        enqueueSnackbar(`Attention: Un crédit de ${formatCurrency(Math.abs(response.client_balance))} a été accordé à ce client`, { 
          variant: 'warning',
          autoHideDuration: 10000,
          anchorOrigin: {
            vertical: 'top',
            horizontal: 'center',
          }
        });
      }
      if (response.sale.payment_status === 'partially_paid') {
        const paidAmount = response.sale.paid_amount;
        const totalAmount = response.sale.total_amount;
        const remainingAmount = response.sale.remaining_amount;
        successMsg += `\nPaiement partiel: ${formatCurrency(paidAmount)} payé, ${formatCurrency(remainingAmount)} restant.`;
        enqueueSnackbar(
          <Box>
            <Typography variant="subtitle2">Paiement partiel enregistré</Typography>
            <Typography variant="body2">
              {formatCurrency(paidAmount)} payé sur {formatCurrency(totalAmount)}
              <br />
              {formatCurrency(remainingAmount)} restant à payer
            </Typography>
          </Box>, 
          { 
            variant: 'info',
            autoHideDuration: 8000,
            anchorOrigin: {
              vertical: 'bottom',
              horizontal: 'center',
            }
          }
        );
      }
      setSuccessMessage(successMsg);
      setShowSuccessSnackbar(true);
      setTimeout(() => {
        setShowSuccessSnackbar(false);
        setSuccessMessage(null);
      }, 6000);
      if (selectedClient) {
        if (clientBalanceData) {
          setPreviousBalance(clientBalanceData.balance);
        }
        loadClientAccountData(selectedClient.id);
      }
      setShowPaymentModal(false);
      resetPaymentForm();
      setSelectedCompanyAccount(null);
      setProcessingPayment(false);
    } catch (err) {
      console.error('Error processing payment:', err);
      setError('Erreur lors du traitement du paiement. Veuillez réessayer.');
      setProcessingPayment(false);
    }
  };
    // Reset payment form
  const resetPaymentForm = () => {
    setSelectedSaleForPayment(null);
    setPaymentAmount(0);
    setPaymentDescription('');
  };

  // Handle supplier payment
  const handleSupplierPayment = async () => {
    if (!selectedSupplyForPayment || !selectedSupplier) {
      setError('Veuillez sélectionner un approvisionnement pour payer.');
      return;
    }

    if (supplierPaymentAmount <= 0) {
      setError('Le montant du paiement doit être supérieur à zéro.');
      return;
    }

    if (!selectedSupplierCompanyAccount) {
      setError('Veuillez sélectionner un compte de l\'entreprise pour effectuer le paiement.');
      return;
    }

    setProcessingSupplierPayment(true);
    setError(null);

    try {
      const response = await InventoryAPI.paySupplierFromAccount(
        selectedSupplyForPayment.id,
        {
          amount: supplierPaymentAmount,
          description: supplierPaymentDescription || `Paiement pour l'approvisionnement ${selectedSupplyForPayment.reference} au fournisseur`,
          company_account: selectedSupplierCompanyAccount.id
        }
      );

      const paymentAmount = parseFloat(response.payment.amount);
      let successMsg = `Paiement de ${formatCurrency(paymentAmount)} traité avec succès. Nouveau solde fournisseur: ${formatCurrency(response.supplier_balance)}, Solde entreprise: ${formatCurrency(response.company_balance)}`;

      if (response.supply.payment_status === 'partially_paid') {
        const paidAmount = parseFloat(response.supply.paid_amount);
        const totalAmount = parseFloat(response.supply.total_amount);
        const remainingAmount = parseFloat(response.supply.remaining_amount);
        
        successMsg += `\nPaiement partiel: ${formatCurrency(paidAmount)} payé, ${formatCurrency(remainingAmount)} restant.`;
        
        enqueueSnackbar(
          <Box>
            <Typography variant="subtitle2">Paiement partiel enregistré</Typography>
            <Typography variant="body2">
              {formatCurrency(paidAmount)} payé sur {formatCurrency(totalAmount)}
              <br />
              {formatCurrency(remainingAmount)} restant à payer
            </Typography>
          </Box>,
          {
            variant: 'info',
            autoHideDuration: 8000,
            anchorOrigin: {
              vertical: 'bottom',
              horizontal: 'center',
            }
          }
        );
      }

      setSuccessMessage(successMsg);
      setShowSuccessSnackbar(true);
      setTimeout(() => {
        setShowSuccessSnackbar(false);
        setSuccessMessage(null);
      }, 6000);

      // Reload supplier data
      if (selectedSupplier) {
        if (supplierBalanceData) {
          setPreviousBalance(supplierBalanceData.balance);
        }
        loadSupplierAccountData(selectedSupplier.id);
      }

      // Close modal and reset form
      setShowSupplierPaymentModal(false);
      resetSupplierPaymentForm();
      setSelectedSupplierCompanyAccount(null);
      setProcessingSupplierPayment(false);
    } catch (err) {
      console.error('Error processing supplier payment:', err);
      setError('Erreur lors du traitement du paiement fournisseur. Veuillez réessayer.');
      setProcessingSupplierPayment(false);
    }
  };

  // Reset supplier payment form
  const resetSupplierPaymentForm = () => {
    setSelectedSupplyForPayment(null);
    setSupplierPaymentAmount(0);
    setSupplierPaymentDescription('');
  };

  // Handle client pagination
  const handleChangeClientPage = (event: unknown, newPage: number) => {
    setClientPage(newPage);
  };

  // Handle supplier pagination
  const handleChangeSupplierPage = (event: unknown, newPage: number) => {
    setSupplierPage(newPage);
  }

  const handleChangeClientRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setClientRowsPerPage(parseInt(event.target.value, 10));
    setClientPage(0);
  }; 
  const handleChangeSupplierRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setSupplierRowsPerPage(parseInt(event.target.value, 10));
    setSupplierPage(0);
  }

  // Consolidated function to load account data for clients or suppliers
  const loadAccountData = async (entityId: number, entityType: 'client' | 'supplier') => {
    try {
      // Set the appropriate loading state
      if (entityType === 'client') {
        setLoadingClientData(true);
      } else {
        setLoadingSupplierData(true);
      }
      setError(null);
      
      // Store previous balance for feedback
      const currentData = entityType === 'client' ? clientBalanceData : supplierBalanceData;
      const prevBalance = currentData ? currentData.balance : null;
      
      // Get entity data to access account ID
      const entityData = entityType === 'client' ? 
        (selectedClient || await ClientsAPI.getById(entityId)) :
        (selectedSupplier || await SuppliersAPI.getById(entityId));
      const accountId = entityData?.account;
      
      if (!accountId) {
        throw new Error(`No account found for this ${entityType === 'client' ? 'client' : 'fournisseur'}`);
      }
      
      // Single API call for all comprehensive data
      const accountInfo = await TreasuryAPI.getAccountInfo(accountId, entityType);
      
      console.log(`${entityType} account info loaded:`, accountInfo);
      
      // Set the data with proper type handling
      // The new API returns a simplified structure, so we cast through unknown
      if (entityType === 'client') {
        setClientBalanceData(accountInfo as unknown as ActualClientBalanceResponse);
      } else {
        setSupplierBalanceData(accountInfo as unknown as ActualSupplierBalanceResponse);
      }
      
      // Show balance update feedback if balance changed
      if (prevBalance !== null && accountInfo.balance !== prevBalance) {
        showBalanceUpdateFeedback(prevBalance, accountInfo.balance);
      }
    } catch (err) {
      console.error(`Error loading ${entityType} account data:`, err);
      setError(`Erreur lors du chargement des données du compte ${entityType === 'client' ? 'client' : 'fournisseur'}.`);
      
      // Clear data
      if (entityType === 'client') {
        setClientBalanceData(null);
      } else {
        setSupplierBalanceData(null);
      }
    } finally {
      // Set loading to false
      if (entityType === 'client') {
        setLoadingClientData(false);
      } else {
        setLoadingSupplierData(false);
      }
    }
  };

  // Wrapper functions for backwards compatibility and convenience
  const loadClientAccountData = async (clientId: number) => {
    await loadAccountData(clientId, 'client');
  };

  const loadSupplierAccountData = async (supplierId: number) => {
    await loadAccountData(supplierId, 'supplier');
  };
  
  // Handle client selection change
  const handleClientChange = (client: Client | null) => {
    setSelectedClient(client);
    setClientBalanceData(null);
    if (client) {
      loadClientAccountData(client.id);
      
      // Pre-fill deposit form with client data
      setNewDeposit(prev => ({
        ...prev,
        client: client.id,
        account: client.account || null
      }));
    }
  };

  const handleSupplierChange = (supplier: Supplier | null) => {
    setSelectedSupplier(supplier);
    if (supplier) {
      loadSupplierAccountData(supplier.id);

      // Pre-fill deposit form with client data
      setNewDeposit(prev => ({
        ...prev,
        client: supplier.id,
        account: supplier.account || null
      }));
    }
  }

  // Handle creating a client deposit
  const handleCreateDeposit = async () => {
    try {
      setError(null);

      // Validate required fields using utility function
      const validationError = validateDepositForm(newDeposit);
      if (validationError) {
        setError(validationError);
        return;
      }      // Store current balance for comparison
      const currentBalance = clientBalanceData?.balance || 0;      // Prepare data for API
      const depositData = {
        reference: `DEP-${Date.now()}`, // Generate unique reference
        client: newDeposit.client,
        account: newDeposit.account,
        amount: newDeposit.amount,
        allocated_amount: newDeposit.amount, // Set allocated_amount to the full amount
        payment_method: newDeposit.payment_method?.id || null,
        date: newDeposit.date,
        description: newDeposit.description || 'Dépôt sur compte client'
      };

      // Call API to create cash receipt
      await TreasuryAPI.createCashReceipt(depositData);

      // Show enhanced success message with amount details
      const successMsg = `Dépôt de ${formatCurrency(newDeposit.amount)} créé avec succès`;
      setSuccessMessage(successMsg);
      setShowSuccessSnackbar(true);
      setTimeout(() => {
        setShowSuccessSnackbar(false);
        setSuccessMessage(null);
      }, 6000);

      // Close modal and refresh client data
      setShowDepositModal(false);
      
      // Reset form
      setNewDeposit({
        client: selectedClient?.id || null,
        account: null,
        amount: 0,
        payment_method: null,
        date: new Date().toISOString().split('T')[0],
        description: 'Dépôt sur compte'
      });      
      // Refresh data
      if (selectedClient) {
        // Save previous balance before refresh
        setPreviousBalance(currentBalance);
        // Reload client data to get updated balance
        loadClientAccountData(selectedClient.id);
      }
    } catch (err) {
      console.error('Error creating deposit:', err);
      setError('Erreur lors de la création du dépôt. Veuillez réessayer.');
    }
  };

  // Show visual feedback when balance is updated
  const showBalanceUpdateFeedback = (previousAmount: number, newAmount: number) => {
    // Store previous balance
    setPreviousBalance(previousAmount);
    
    // Highlight the balance change
    setBalanceChangeHighlight(true);
    
    // Display notification
    const isIncrease = newAmount > previousAmount;
    const difference = Math.abs(newAmount - previousAmount);
    
    enqueueSnackbar(
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        <Avatar 
          sx={{ 
            bgcolor: isIncrease ? 'success.main' : 'error.main', 
            width: 32, 
            height: 32,
            mr: 1.5
          }}
        >
          {isIncrease ? '+' : '-'}
        </Avatar>
        <Box>
          <Typography variant="body2" fontWeight={500}>
            {isIncrease ? 'Dépôt effectué' : 'Retrait effectué'}
          </Typography>
          <Typography variant="caption" sx={{ display: 'block' }}>
            {isIncrease ? 'Crédit' : 'Débit'} de {formatCurrency(difference)}
          </Typography>
        </Box>
      </Box>,
      { 
        variant: isIncrease ? 'success' : 'warning',
        anchorOrigin: {
          vertical: 'bottom',
          horizontal: 'right',
        },
        TransitionComponent: Grow,
        autoHideDuration: 5000
      }
    );
    
    // Reset highlight after animation completes
    setTimeout(() => {
      setBalanceChangeHighlight(false);
    }, 3000);
  };

  return (
    <PermissionGuard requiredPermission="view_cashreceipt" fallbackPath="/">
      <Box>
      <Box 
        sx={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          mb: 3
        }}
      >
        <Box>
          <Typography variant="h4" fontWeight="bold" gutterBottom>
            Trésorerie
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Gestion des paiements et comptes clients
          </Typography>
        </Box>        <Box>
          {tabValue === 0 && selectedClient && (
            <Stack direction="row" spacing={2}>
              <Button
                variant="outlined"
                color="primary"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                  setSelectedClient(null);
                  setClientBalanceData(null);
                }}
                sx={{ borderRadius: 2 }}
              >
                Retour
              </Button>
            </Stack>
          )}
        </Box>
      </Box>

      <StyledPaper>        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>          <Tabs
            value={tabValue}
            onChange={handleTabChange}
            indicatorColor="primary"
            variant="fullWidth"
            aria-label="treasury tabs"
          >
            <Tab 
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <AccountBalanceWalletIcon fontSize="small" />
                  <span>Comptes Clients</span>
                </Box>
              } 
              {...a11yProps(0)} 
            />
            <Tab 
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <WalletIcon fontSize="small" />
                  <span>Comptes Fournisseurs</span>
                </Box>
              } 
              {...a11yProps(1)} 
            />
            <Tab 
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <MoneyIcon fontSize="small" />
                  <span>Comptes Entreprise</span>
                </Box>
              } 
              {...a11yProps(2)} 
            />
            <Tab 
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <ReceiptIcon fontSize="small" />
                  <span>Mouvements</span>
                </Box>
              } 
              {...a11yProps(3)} 
            />
          </Tabs>
        </Box>        
        {/* Client Accounts Tab */}
        <TabPanel value={tabValue} index={0}>
          <Grid container spacing={3}>
            {!selectedClient ? (
              <>
                <Grid item xs={12}>
                  <Box sx={{ mb: 3 }}>
                    <Typography variant="h6" gutterBottom>
                      Sélectionner un client
                    </Typography>
                    <TextField
                      fullWidth
                      label="Rechercher un client"
                      variant="outlined"
                      value={clientSearch}
                      onChange={(e) => setClientSearch(e.target.value)}
                      InputProps={{
                        startAdornment: <SearchIcon fontSize="small" sx={{ mr: 1, color: 'text.secondary' }} />,
                      }}
                      sx={{ mb: 3 }}
                    />
                  </Box>
                  
                  {error && (
                    <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
                      {error}
                    </Alert>
                  )}
                  
                  <Grid container spacing={2}>
                    {paginatedClients.map(client => (
                        <Grid item xs={12} sm={6} md={4} key={client.id}>
                          <ClientInfoCard
                            onClick={() => handleClientChange(client)}
                            sx={{ 
                              cursor: 'pointer',
                              height: '100%',
                            }}
                          >
                            <CardContent>
                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                  <Avatar sx={{ bgcolor: 'primary.main', mr: 1 }}>
                                    {client.name.charAt(0).toUpperCase()}
                                  </Avatar>
                                  <Typography variant="h6" sx={{ fontWeight: 'bold' }}>
                                    {client.name}
                                  </Typography>
                                </Box>
                                {client.is_active ? 
                                  <Chip size="small" label="Actif" color="success" /> : 
                                  <Chip size="small" label="Inactif" color="default" />
                                }
                              </Box>
                              
                              {client.contact_person && (
                                <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                                  Contact: {client.contact_person}
                                </Typography>
                              )}
                              
                              {client.phone && (
                                <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                                  Tél: {client.phone}
                                </Typography>
                              )}
                              
                              <Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
                                <Button 
                                  variant="outlined" 
                                  color="primary"
                                  size="small"
                                  startIcon={<AccountBalanceWalletIcon />}
                                >
                                  Consulter compte
                                </Button>
                              </Box>
                            </CardContent>
                          </ClientInfoCard>
                        </Grid>
                      ))}
                    
                    {filteredClients.length === 0 && (
                      <Grid item xs={12}>
                        <Paper sx={{ p: 4, textAlign: 'center', bgcolor: 'background.default' }}>
                          <PersonIcon sx={{ fontSize: 60, color: 'text.secondary', mb: 2 }} />
                          <Typography variant="h6" color="text.secondary" gutterBottom>
                            Aucun client trouvé
                          </Typography>
                          <Typography variant="body2" color="text.secondary">
                            Essayez d'autres termes de recherche
                          </Typography>
                        </Paper>
                      </Grid>
                    )}
                  </Grid>
                  <TablePagination
                    rowsPerPageOptions={[6, 12, 18]}
                    component="div"
                    count={filteredClients.length}
                    rowsPerPage={clientRowsPerPage}
                    page={clientPage}
                    onPageChange={handleChangeClientPage}
                    onRowsPerPageChange={handleChangeClientRowsPerPage}
                    labelRowsPerPage="Clients par page:"
                    labelDisplayedRows={({ from, to, count }) => `${from}-${to} sur ${count}`}
                  />
                </Grid>
              </>
            ) : (
              <>
                {/* Single row layout with merged client info and balance */}
                <Grid item xs={12}>
                  {loadingClientData ? (
                    <Card sx={{ mb: 3 }} elevation={2}>
                      <CardContent>
                        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                          <CircularProgress />
                          <Typography variant="body1" sx={{ ml: 2 }}>
                            Chargement des données du client...
                          </Typography>
                        </Box>
                      </CardContent>
                    </Card>
                  ) : (
                    <Card sx={{ mb: 3 }} elevation={2}>
                      <CardContent>
                        <Grid container alignItems="center" spacing={3}>
                          {/* Client Info Section */}
                          <Grid item xs={12} md={4}>
                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                              <Avatar sx={{ bgcolor: 'primary.main', mr: 2, width: 56, height: 56 }}>
                                {selectedClient.name.charAt(0).toUpperCase()}
                              </Avatar>
                              <Box>
                                <Typography variant="h6" fontWeight="bold">
                                  {selectedClient.name}
                                </Typography>
                                {selectedClient.contact_person && (
                                  <Typography variant="body2" color="text.secondary">
                                    {selectedClient.contact_person}
                                  </Typography>
                                )}
                              </Box>
                            </Box>
                            
                            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                              {selectedClient.phone && (
                                <Chip 
                                  icon={<Typography>📞</Typography>} 
                                  label={selectedClient.phone} 
                                  variant="outlined" 
                                  size="small"
                                />
                              )}
                              {selectedClient.email && (
                                <Chip 
                                  icon={<Typography>✉️</Typography>} 
                                  label={selectedClient.email} 
                                  variant="outlined" 
                                  size="small"
                                />
                              )}
                              {selectedClient.address && (
                                <Chip 
                                  icon={<Typography>🏠</Typography>} 
                                  label={selectedClient.address} 
                                  variant="outlined" 
                                  size="small"
                                />
                              )}
                            </Box>
                          </Grid>
                        
                        {/* Balance Section */}
                        <Grid item xs={12} md={4}>
                          <Box sx={{ textAlign: 'center' }}>
                            <Typography variant="body2" color="text.secondary" gutterBottom>
                              Solde actuel
                            </Typography>
                            <Grow
                              in={true}
                              style={{ transformOrigin: '0 0 0' }}
                              {...(balanceChangeHighlight ? { timeout: 1000 } : {})}
                            >
                              <Typography
                                variant="h4" 
                                sx={{ 
                                  fontWeight: 'bold',
                                  color: clientBalanceData?.balance >= 0 ? 'success.main' : 'error.main',
                                  transition: 'color 0.5s ease',
                                  animation: balanceChangeHighlight ? 'pulse 2s infinite' : 'none',
                                  '@keyframes pulse': {
                                    '0%': {
                                      opacity: 1,
                                    },
                                    '50%': {
                                      opacity: 0.6,
                                    },
                                    '100%': {
                                      opacity: 1,
                                    },
                                  },
                                }}
                              >
                                {clientBalanceData.balance ? formatCurrency(clientBalanceData.balance) : formatCurrency(0)}
                              </Typography>
                            </Grow>
                            {previousBalance !== null && clientBalanceData && previousBalance !== clientBalanceData.balance && (
                              <Slide direction="up" in={balanceChangeHighlight} mountOnEnter unmountOnExit>
                                <Typography variant="caption" 
                                  sx={{ 
                                    color: clientBalanceData.balance > previousBalance ? 'success.main' : 'error.main',
                                    fontWeight: 'medium'
                                  }}
                                >
                                  {clientBalanceData.balance > previousBalance ? '↑' : '↓'} 
                                  {formatCurrency(Math.abs(clientBalanceData.balance - previousBalance))}
                                </Typography>
                              </Slide>
                            )}
                          </Box>
                        </Grid>
                        
                        {/* Action Buttons Section */}
                        <Grid item xs={12} md={4}>
                          <Stack direction="row" spacing={1} justifyContent={{ xs: 'center', md: 'flex-end' }}>
                            <Button
                              variant="contained"
                              color="primary"
                              startIcon={<AttachMoneyIcon />}
                              onClick={() => setShowDepositModal(true)}
                              size="small"
                            >
                              Nouveau dépôt
                            </Button>
                            <Button
                              variant="outlined"
                              startIcon={<ArrowBackIcon />}
                              onClick={() => {
                                setSelectedClient(null);
                                setClientBalanceData(null);
                              }}
                              size="small"
                            >
                              Retour
                            </Button>
                          </Stack>
                        </Grid>
                      </Grid>
                    </CardContent>
                  </Card>
                  )}
                </Grid>

                {/* Data sections */}
                <Grid item xs={12}>
                  {loadingClientData ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                      <CircularProgress />
                    </Box>
                  ) : error ? (
                    <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
                      {error}
                    </Alert>
                  ) : clientBalanceData ? (
                    <Box>

                      {clientBalanceData.outstanding_sales && clientBalanceData.outstanding_sales.length > 0 && (
                        <Paper sx={{ mb: 3, overflow: 'hidden' }} elevation={2}>
                          <Box sx={{ bgcolor: 'warning.light', px: 2, py: 1.5, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Typography variant="subtitle1" fontWeight="bold" color="warning.contrastText">
                              <WarningIcon sx={{ fontSize: 20, mr: 1, verticalAlign: 'text-bottom' }} />
                              Ventes non soldées ({clientBalanceData.outstanding_sales?.length || 0})
                            </Typography>
                            <Box>
                              <Tooltip title="Filtrer les ventes">
                                <IconButton size="small" sx={{ color: 'warning.contrastText' }}>
                                  <FilterListIcon fontSize="small" />
                                </IconButton>
                              </Tooltip>
                            </Box>
                          </Box>
                          
                          <Box sx={{ 
                            height: Math.min(Math.max(50, clientBalanceData.outstanding_sales.length * 60 + 160), 300), 
                            width: '100%' 
                          }}>
                            <DataGrid
                              rowHeight={70}
                              rows={(clientBalanceData.outstanding_sales || []).map((sale: OutstandingSale) => ({
                                id: sale.id,
                                reference: sale.reference,
                                date: formatDate(sale.date),
                                rawDate: sale.date,
                                total_amount: sale.total_amount,
                                paid_amount: sale.paid_amount,
                                balance: sale.payment_status === 'unpaid' && sale.balance === 0 ? sale.total_amount : sale.balance,
                                payment_status: sale.payment_status,
                                actions: sale
                              }))}
                              columns={[
                                { 
                                  field: 'date', 
                                  headerName: 'Date', 
                                  width: 120,
                                  sortComparator: (v1, v2, param1, param2) => {
                                    const d1 = new Date(param1.api.getCellValue(param1.id, 'rawDate'));
                                    const d2 = new Date(param2.api.getCellValue(param2.id, 'rawDate'));
                                    return d1.getTime() - d2.getTime();
                                  }
                                },
                                { field: 'reference', headerName: 'Référence', width: 140 },
                                { 
                                  field: 'total_amount', 
                                  headerName: 'Montant', 
                                  width: 130,
                                  align: 'right',
                                  headerAlign: 'right',
                                  renderCell: (params) => (
                                    <Typography variant="body2" fontWeight="500">
                                      {formatCurrency(params.value)}
                                    </Typography>
                                  )
                                },
                                { 
                                  field: 'paid_amount', 
                                  headerName: 'Payé', 
                                  width: 130,
                                  align: 'right',
                                  headerAlign: 'right',
                                  renderCell: (params) => (
                                    params.value > 0 ? (
                                      <Typography variant="body2" sx={{ color: 'success.main', fontWeight: 500 }}>
                                        {formatCurrency(params.value)}
                                      </Typography>
                                    ) : null
                                  )
                                },
                                { 
                                  field: 'balance', 
                                  headerName: 'Solde', 
                                  width: 130,
                                  align: 'right',
                                  headerAlign: 'right',
                                  renderCell: (params) => (
                                    <Typography 
                                      variant="body2" 
                                      fontWeight="bold"
                                      sx={{ 
                                        color: 'error.main',
                                        backgroundColor: 'rgba(211, 47, 47, 0.1)',
                                        py: 0.5,
                                        px: 1,
                                        borderRadius: 1,
                                        fontSize: '0.8125rem'
                                      }}
                                    >
                                      {formatCurrency(params.value)}
                                    </Typography>
                                  )
                                },
                                { 
                                  field: 'payment_status', 
                                  headerName: 'Statut', 
                                  width: 140,
                                  renderCell: (params) => (
                                    <Chip
                                      label={getPaymentStatusLabel(params.value)}
                                      color={getPaymentStatusColor(params.value)}
                                      size="small"
                                      sx={{ fontWeight: 500 }}
                                    />
                                  )
                                },
                                { 
                                  field: 'actions', 
                                  headerName: 'Actions', 
                                  width: 290,
                                  align: 'center',
                                  headerAlign: 'center',
                                  sortable: false,
                                  renderCell: (params) => (
                                    <Tooltip title="Effectuer un paiement sur cette vente">
                                      <Button
                                        variant="contained"
                                        color="success"
                                        size="medium"
                                        startIcon={<PaymentIcon />}
                                        sx={{
                                          borderRadius: 2,
                                          fontWeight: 'bold',
                                          px: 2,
                                          boxShadow: 2,
                                          textTransform: 'none',
                                        }}
                                        onClick={() => {
                                          const sale = params.value;
                                          const actualBalance = sale.payment_status === 'unpaid' && sale.balance === 0 
                                            ? sale.total_amount 
                                            : sale.balance;

                                          const saleWithCorrectBalance = {
                                            ...sale,
                                            balance: actualBalance
                                          };

                                          setSelectedSaleForPayment(saleWithCorrectBalance);

                                          if (clientBalanceData) {
                                            const availableBalance = clientBalanceData.balance;
                                            if (availableBalance > 0 && availableBalance < actualBalance) {
                                              setPaymentAmount(availableBalance);
                                            } else {
                                              setPaymentAmount(actualBalance);
                                            }
                                          } else {
                                            setPaymentAmount(actualBalance);
                                          }

                                          setPaymentDescription(`Paiement pour la vente ${sale.reference}`);
                                          setShowPaymentModal(true);
                                        }}
                                      >
                                        Effectuer un paiement
                                      </Button>
                                    </Tooltip>
                                  )
                                }
                              ]}
                              getRowClassName={(params) => 
                                params.indexRelativeToCurrentPage % 2 === 0 ? '' : 'even-row'
                              }
                              initialState={{
                                pagination: {
                                  paginationModel: { pageSize: 5, page: 0 },
                                },
                                sorting: {
                                  sortModel: [{ field: 'rawDate', sort: 'desc' }],
                                },
                              }}
                              density="compact"
                              disableRowSelectionOnClick
                              slots={{
                                toolbar: GridToolbar,
                              }}
                              slotProps={{
                                toolbar: {
                                  showQuickFilter: true,
                                  quickFilterProps: { debounceMs: 300 },
                                },
                              }}
                              sx={{
                                border: 'none',
                                '& .MuiDataGrid-cell:focus': {
                                  outline: 'none',
                                },
                                '& .even-row': {
                                  bgcolor: 'rgba(0, 0, 0, 0.02)',
                                },
                                '& .MuiDataGrid-columnHeaders': {
                                  backgroundColor: 'rgba(0, 0, 0, 0.03)',
                                  borderRadius: 0,
                                }
                              }}
                              pageSizeOptions={[5, 10, 25]}
                            />
                          </Box>
                        </Paper>
                      )}
                     <TransactionsTabs clientBalanceData={clientBalanceData} />
                    </Box>
                  ) : (
                    <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '300px' }}>
                      <CircularProgress />
                    </Box>
                  )}
                </Grid>
              </>
            )}
          </Grid>
        </TabPanel>

        {/* Supplier Accounts Tab */}
        <TabPanel value={tabValue} index={1}>
          <Grid container spacing={3}>
             {! selectedSupplier ? (
              <>
                <Grid item xs={12}>
                  <Box sx={{ mb: 3 }}>
                    <Typography variant="h6" gutterBottom>
                      Sélectionner un fournisseur
                    </Typography>
                    <TextField
                      fullWidth
                      label="Rechercher un fournisseur"
                      variant="outlined"
                      value={supplierSearch}
                      onChange={(e) => setSupplierSearch(e.target.value)}
                      InputProps={{
                        startAdornment: <SearchIcon fontSize="small" sx={{ mr: 1, color: 'text.secondary' }} />,
                      }}
                      sx={{ mb: 3 }}
                    />
                  </Box>
                  
                  {error && (
                    <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
                      {error}
                    </Alert>
                  )}
                  
                  <Grid container spacing={2}>
                    {paginatedSuppliers.map(supplier => (
                        <Grid item xs={12} sm={6} md={4} key={supplier.id}>
                          <ClientInfoCard
                            onClick={() => handleSupplierChange(supplier)}
                            sx={{
                              cursor: 'pointer',
                              height: '100%',
                            }}
                          >
                            <CardContent>
                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                  <Avatar sx={{ bgcolor: 'primary.main', mr: 1 }}>
                                    {supplier.name.charAt(0).toUpperCase()}
                                  </Avatar>
                                  <Typography variant="h6" sx={{ fontWeight: 'bold' }}>
                                    {supplier.name}
                                  </Typography>
                                </Box>
                                {supplier.is_active ? 
                                  <Chip size="small" label="Actif" color="success" /> : 
                                  <Chip size="small" label="Inactif" color="default" />
                                }
                              </Box>

                              {supplier.contact_person && (
                                <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                                  Contact: {supplier.contact_person}
                                </Typography>
                              )}
                              
                              {supplier.phone && (
                                <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                                  Tél: {supplier.phone}
                                </Typography>
                              )}
                              
                              <Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
                                <Button 
                                  variant="outlined" 
                                  color="primary"
                                  size="small"
                                  startIcon={<AccountBalanceWalletIcon />}
                                >
                                  Consulter compte
                                </Button>
                              </Box>
                            </CardContent>
                          </ClientInfoCard>
                        </Grid>
                      ))}
                    
                    {filteredSuppliers.length === 0 && (
                      <Grid item xs={12}>
                        <Paper sx={{ p: 4, textAlign: 'center', bgcolor: 'background.default' }}>
                          <PersonIcon sx={{ fontSize: 60, color: 'text.secondary', mb: 2 }} />
                          <Typography variant="h6" color="text.secondary" gutterBottom>
                            Aucun s trouvé
                          </Typography>
                          <Typography variant="body2" color="text.secondary">
                            Essayez d'autres termes de recherche
                          </Typography>
                        </Paper>
                      </Grid>
                    )}
                  </Grid>
                  <TablePagination
                    rowsPerPageOptions={[6, 12, 18]}
                    component="div"
                    count={filteredSuppliers.length}
                    rowsPerPage={supplierRowsPerPage}
                    page={supplierPage}
                    onPageChange={handleChangeSupplierPage}
                    onRowsPerPageChange={handleChangeSupplierRowsPerPage}
                    labelRowsPerPage="Fournisseurs par page:"
                    labelDisplayedRows={({ from, to, count }) => `${from}-${to} sur ${count}`}
                  />
                </Grid>
              </>
            ) : (
              <>
                {/* Single row layout with merged client info and balance */}
                <Grid item xs={12}>
                  {loadingSupplierData ? (
                    <Card sx={{ mb: 3 }} elevation={2}>
                      <CardContent>
                        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                          <CircularProgress />
                          <Typography variant="body1" sx={{ ml: 2 }}>
                            Chargement des données du client...
                          </Typography>
                        </Box>
                      </CardContent>
                    </Card>
                  ) : (
                    <Card sx={{ mb: 3 }} elevation={2}>
                      <CardContent>
                        <Grid container alignItems="center" spacing={3}>
                          {/* Client Info Section */}
                          <Grid item xs={12} md={4}>
                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                              <Avatar sx={{ bgcolor: 'primary.main', mr: 2, width: 56, height: 56 }}>
                                {selectedSupplier.name.charAt(0).toUpperCase()}
                              </Avatar>
                              <Box>
                                <Typography variant="h6" fontWeight="bold">
                                  {selectedSupplier.name}
                                </Typography>
                                {selectedSupplier.contact_person && (
                                  <Typography variant="body2" color="text.secondary">
                                    {selectedSupplier.contact_person}
                                  </Typography>
                                )}
                              </Box>
                            </Box>
                            
                            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                              {selectedSupplier.phone && (
                                <Chip 
                                  icon={<Typography>📞</Typography>} 
                                  label={selectedSupplier.phone} 
                                  variant="outlined" 
                                  size="small"
                                />
                              )}
                              {selectedSupplier.email && (
                                <Chip 
                                  icon={<Typography>✉️</Typography>} 
                                  label={selectedSupplier.email} 
                                  variant="outlined" 
                                  size="small"
                                />
                              )}
                              {selectedSupplier.address && (
                                <Chip 
                                  icon={<Typography>🏠</Typography>} 
                                  label={selectedSupplier.address} 
                                  variant="outlined" 
                                  size="small"
                                />
                              )}
                            </Box>
                          </Grid>
                        
                        {/* Balance Section */}
                        <Grid item xs={12} md={4}>
                          <Box sx={{ textAlign: 'center' }}>
                            <Typography variant="body2" color="text.secondary" gutterBottom>
                              Solde actuel
                            </Typography>
                            <Grow
                              in={true}
                              style={{ transformOrigin: '0 0 0' }}
                              {...(balanceChangeHighlight ? { timeout: 1000 } : {})}
                            >
                              <Typography
                                variant="h4" 
                                sx={{ 
                                  fontWeight: 'bold',
                                  color: supplierBalanceData?.balance >= 0 ? 'success.main' : 'error.main',
                                  transition: 'color 0.5s ease',
                                  animation: balanceChangeHighlight ? 'pulse 2s infinite' : 'none',
                                  '@keyframes pulse': {
                                    '0%': {
                                      opacity: 1,
                                    },
                                    '50%': {
                                      opacity: 0.6,
                                    },
                                    '100%': {
                                      opacity: 1,
                                    },
                                  },
                                }}
                              >
                                {supplierBalanceData ? formatCurrency(supplierBalanceData.balance) : formatCurrency(0)}
                              </Typography>
                            </Grow>
                            {previousBalance !== null && supplierBalanceData && previousBalance !== supplierBalanceData.balance && (
                              <Slide direction="up" in={balanceChangeHighlight} mountOnEnter unmountOnExit>
                                <Typography variant="caption" 
                                  sx={{ 
                                    color: supplierBalanceData.balance > previousBalance ? 'success.main' : 'error.main',
                                    fontWeight: 'medium'
                                  }}
                                >
                                  {supplierBalanceData.balance > previousBalance ? '↑' : '↓'} 
                                  {formatCurrency(Math.abs(supplierBalanceData.balance - previousBalance))}
                                </Typography>
                              </Slide>
                            )}
                          </Box>
                        </Grid>
                        
                        {/* Action Buttons Section */}
                        <Grid item xs={12} md={4}>
                          <Stack direction="row" spacing={1} justifyContent={{ xs: 'center', md: 'flex-end' }}>
                            <Button
                              variant="outlined"
                              startIcon={<ArrowBackIcon />}
                              onClick={() => {
                                setSelectedSupplier(null);
                                setSupplierBalanceData(null);
                              }}
                              size="small"
                            >
                              Retour
                            </Button>
                          </Stack>
                        </Grid>
                      </Grid>
                    </CardContent>
                  </Card>
                  )}
                </Grid>

                {/* Data sections */}
                <Grid item xs={12}>
                  {loadingSupplierData ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                      <CircularProgress />
                    </Box>
                  ) : error ? (
                    <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
                      {error}
                    </Alert>
                  ) : supplierBalanceData ? (
                    <Box>
                      {/* Outstanding Supplies Section */}
                      {supplierBalanceData.outstanding_supplies && supplierBalanceData.outstanding_supplies.length > 0 && (
                        <Paper 
                          elevation={2} 
                          sx={{ 
                            p: 3, 
                            mb: 3,
                            borderRadius: 2,
                            border: '1px solid',
                            borderColor: 'error.light'
                          }}
                        >
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <WarningIcon sx={{ color: 'error.main', mr: 1 }} />
                            <Typography variant="h6" sx={{ color: 'error.main', fontWeight: 'bold' }}>
                              Approvisionnements non soldés ({supplierBalanceData.outstanding_supplies?.length || 0})
                            </Typography>
                          </Box>
                          
                          <Box sx={{ 
                            width: '100%',
                            '& .MuiDataGrid-root': {
                              border: 'none',
                            },
                          }}>
                            <DataGrid
                              autoHeight
                              rows={(supplierBalanceData.outstanding_supplies || []).map((supply: OutstandingSupply) => ({
                                id: supply.id,
                                date: formatDate(supply.date),
                                rawDate: supply.date,
                                reference: supply.reference,
                                total_amount: supply.total_amount,
                                paid_amount: supply.paid_amount,
                                balance: supply.remaining_amount,
                                payment_status: supply.payment_status,
                                actions: supply
                              }))}
                              columns={[
                                { 
                                  field: 'date', 
                                  headerName: 'Date', 
                                  width: 120,
                                  sortComparator: (v1, v2, param1, param2) => {
                                    const d1 = new Date(param1.api.getCellValue(param1.id, 'rawDate'));
                                    const d2 = new Date(param2.api.getCellValue(param2.id, 'rawDate'));
                                    return d1.getTime() - d2.getTime();
                                  }
                                },
                                { field: 'reference', headerName: 'Référence', width: 140 },
                                { 
                                  field: 'total_amount', 
                                  headerName: 'Montant', 
                                  width: 130,
                                  align: 'right',
                                  headerAlign: 'right',
                                  renderCell: (params) => (
                                    <Typography variant="body2" fontWeight="500">
                                      {formatCurrency(params.value)}
                                    </Typography>
                                  )
                                },
                                { 
                                  field: 'paid_amount', 
                                  headerName: 'Payé', 
                                  width: 130,
                                  align: 'right',
                                  headerAlign: 'right',
                                  renderCell: (params) => (
                                    params.value > 0 ? (
                                      <Typography variant="body2" sx={{ color: 'success.main', fontWeight: 500 }}>
                                        {formatCurrency(params.value)}
                                      </Typography>
                                    ) : null
                                  )
                                },
                                { 
                                  field: 'balance', 
                                  headerName: 'Solde', 
                                  width: 130,
                                  align: 'right',
                                  headerAlign: 'right',
                                  renderCell: (params) => (
                                    <Typography 
                                      variant="body2" 
                                      fontWeight="bold"
                                      sx={{ 
                                        color: 'error.main',
                                        backgroundColor: 'rgba(211, 47, 47, 0.1)',
                                        py: 0.5,
                                        px: 1,
                                        borderRadius: 1,
                                        fontSize: '0.8125rem'
                                      }}
                                    >
                                      {formatCurrency(params.value)}
                                    </Typography>
                                  )
                                },
                                { 
                                  field: 'payment_status', 
                                  headerName: 'Statut', 
                                  width: 140,
                                  renderCell: (params) => (
                                    <Chip
                                      label={getPaymentStatusLabel(params.value)}
                                      color={getPaymentStatusColor(params.value)}
                                      size="small"
                                      sx={{ fontWeight: 500 }}
                                    />
                                  )
                                },
                                { 
                                  field: 'actions', 
                                  headerName: 'Actions', 
                                  width: 290,
                                  align: 'center',
                                  headerAlign: 'center',
                                  sortable: false,
                                  renderCell: (params) => (
                                    <Tooltip title="Effectuer un paiement pour cet approvisionnement">
                                      <Button
                                        variant="contained"
                                        color="warning"
                                        size="medium"
                                        startIcon={<PaymentIcon />}
                                        sx={{
                                          borderRadius: 2,
                                          fontWeight: 'bold',
                                          px: 2,
                                          boxShadow: 2,
                                          textTransform: 'none',
                                        }}
                                        onClick={() => {
                                          const supply = params.value;
                                          const actualBalance = supply.payment_status === 'unpaid' && supply.balance === 0 
                                            ? supply.total_amount 
                                            : supply.remaining_amount;

                                          const supplyWithCorrectBalance = {
                                            ...supply,
                                            remaining_amount: actualBalance,
                                            balance: actualBalance
                                          };

                                          setSelectedSupplyForPayment(supplyWithCorrectBalance);
                                          setSupplierPaymentAmount(actualBalance);
                                          setSupplierPaymentDescription(`Paiement pour l'approvisionnement ${supply.reference}`);
                                          setShowSupplierPaymentModal(true);
                                        }}
                                      >
                                        Effectuer le paiement
                                      </Button>
                                    </Tooltip>
                                  )
                                }
                              ]}
                              density="comfortable"
                              disableRowSelectionOnClick
                              getRowClassName={(params) =>
                                params.indexRelativeToCurrentPage % 2 === 0 ? 'even-row' : 'odd-row'
                              }
                              sx={{
                                border: 'none',
                                '& .MuiDataGrid-cell:focus': {
                                  outline: 'none',
                                },
                                '& .even-row': {
                                  bgcolor: 'rgba(0, 0, 0, 0.02)',
                                },
                                '& .MuiDataGrid-columnHeaders': {
                                  backgroundColor: 'rgba(0, 0, 0, 0.03)',
                                  borderRadius: 0,
                                }
                              }}
                              pageSizeOptions={[5, 10, 25]}
                            />
                          </Box>
                        </Paper>
                      )}
                      
                      {/* Supplier Transaction History Tabs */}
                      <SupplierTransactionsTabs supplierBalanceData={supplierBalanceData} />
                    </Box>
                  ) : (
                    <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '300px' }}>
                      <CircularProgress />
                    </Box>
                  )}
                </Grid>
              </>
            )}
          </Grid>
        </TabPanel>

        {/* Company Accounts Tab */}
        <TabPanel value={tabValue} index={2}>
          <Grid container spacing={3}>
            {/* Company Accounts Overview */}
            <Grid item xs={12}>
              <Typography variant="h5" gutterBottom sx={{ mb: 3, display: 'flex', alignItems: 'center', fontWeight: 'bold' }}>
                <AccountBalanceIcon sx={{ mr: 1, fontSize: 32, color: 'primary.main' }} />
                Comptes de l'Entreprise
              </Typography>
            </Grid>

            {/* Summary Stats */}
            <Grid item xs={12}>
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6} md={3}>
                  <Card sx={{ bgcolor: 'success.light', height: '100%' }}>
                    <CardContent>
                      <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        <WalletIcon sx={{ color: 'success.dark', mr: 1, fontSize: 28 }} />
                        <Typography variant="body2" color="success.dark" fontWeight="medium">
                          Total Caisses
                        </Typography>
                      </Box>
                      <Typography variant="h4" fontWeight="bold" color="success.dark">
                        {formatCurrency(
                          allAccounts
                            .filter(acc => acc.account_type === 'cash')
                            .reduce((sum, acc) => sum + parseBalance(acc.current_balance), 0)
                        )}
                      </Typography>
                      <Typography variant="caption" color="success.dark">
                        {allAccounts.filter(acc => acc.account_type === 'cash').length} compte(s)
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
                
                <Grid item xs={12} sm={6} md={3}>
                  <Card sx={{ bgcolor: 'primary.light', height: '100%' }}>
                    <CardContent>
                      <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        <AccountBalanceIcon sx={{ color: 'primary.dark', mr: 1, fontSize: 28 }} />
                        <Typography variant="body2" color="primary.dark" fontWeight="medium">
                          Total Banques
                        </Typography>
                      </Box>
                      <Typography variant="h4" fontWeight="bold" color="primary.dark">
                        {formatCurrency(
                          allAccounts
                            .filter(acc => acc.account_type === 'bank')
                            .reduce((sum, acc) => sum + parseBalance(acc.current_balance), 0)
                        )}
                      </Typography>
                      <Typography variant="caption" color="primary.dark">
                        {allAccounts.filter(acc => acc.account_type === 'bank').length} compte(s)
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
                
                <Grid item xs={12} sm={6} md={3}>
                  <Card sx={{ bgcolor: 'info.light', height: '100%' }}>
                    <CardContent>
                      <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        <AccountBalanceWalletIcon sx={{ color: 'info.dark', mr: 1, fontSize: 28 }} />
                        <Typography variant="body2" color="info.dark" fontWeight="medium">
                          Trésorerie Totale
                        </Typography>
                      </Box>
                      <Typography variant="h4" fontWeight="bold" color="info.dark">
                        {formatCurrency(
                          allAccounts
                            .filter(acc => acc.account_type !== 'client' && acc.account_type !== 'supplier')
                            .reduce((sum, acc) => sum + parseBalance(acc.current_balance), 0)
                        )}
                      </Typography>
                      <Typography variant="caption" color="info.dark">
                        Liquidités disponibles
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
                
                <Grid item xs={12} sm={6} md={3}>
                  <Card sx={{ 
                    bgcolor: allAccounts.some(acc => 
                      (acc.account_type === 'cash' || acc.account_type === 'bank' || acc.account_type === 'internal') && 
                      parseBalance(acc.current_balance) < 0
                    ) ? 'error.light' : 'grey.100',
                    height: '100%'
                  }}>
                    <CardContent>
                      <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        <WarningIcon sx={{ 
                          color: allAccounts.some(acc => 
                            (acc.account_type === 'cash' || acc.account_type === 'bank' || acc.account_type === 'internal') && 
                            parseBalance(acc.current_balance) < 0
                          ) ? 'error.dark' : 'text.secondary',
                          mr: 1,
                          fontSize: 28
                        }} />
                        <Typography variant="body2" color="text.secondary" fontWeight="medium">
                          Comptes négatifs
                        </Typography>
                      </Box>
                      <Typography variant="h4" fontWeight="bold">
                        {allAccounts.filter(acc => 
                          (acc.account_type === 'cash' || acc.account_type === 'bank' || acc.account_type === 'internal') && 
                          parseBalance(acc.current_balance) < 0
                        ).length}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        Nécessite attention
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
              </Grid>
            </Grid>

            {/* Individual Account Cards */}
            <Grid item xs={12}>
              <Typography variant="h6" gutterBottom sx={{ mt: 2, mb: 2 }}>
                Détails des comptes
              </Typography>
              <Grid container spacing={2}>
                {allAccounts
                  .filter(acc => acc.account_type !== 'client' && acc.account_type !== 'supplier')
                  .map((account) => (
                    <Grid item xs={12} sm={6} md={4} key={account.id}>
                      <Card 
                        elevation={2}
                        sx={{ 
                          height: '100%',
                          border: parseBalance(account.current_balance) < 0 ? 2 : 1,
                          borderColor: parseBalance(account.current_balance) < 0 ? 'error.main' : 'divider',
                          transition: 'all 0.2s',
                          '&:hover': {
                            transform: 'translateY(-4px)',
                            boxShadow: 6
                          }
                        }}
                      >
                        <CardContent>
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                              {account.account_type === 'bank' ? (
                                <AccountBalanceIcon sx={{ fontSize: 32, color: 'primary.main', mr: 1 }} />
                              ) : account.account_type === 'cash' ? (
                                <WalletIcon sx={{ fontSize: 32, color: 'success.main', mr: 1 }} />
                              ) : (
                                <AccountBalanceWalletIcon sx={{ fontSize: 32, color: 'info.main', mr: 1 }} />
                              )}
                            </Box>
                            <Chip 
                              label={
                                account.account_type === 'bank' ? 'Banque' : 
                                account.account_type === 'cash' ? 'Caisse' : 
                                'Interne'
                              } 
                              size="small" 
                              color={
                                account.account_type === 'bank' ? 'primary' : 
                                account.account_type === 'cash' ? 'success' : 
                                'info'
                              }
                            />
                          </Box>
                          
                          <Typography variant="h6" fontWeight="bold" gutterBottom noWrap>
                            {account.name}
                          </Typography>
                          
                          <Divider sx={{ my: 2 }} />
                          
                          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                              <Typography variant="body2" color="text.secondary">
                                Solde actuel
                              </Typography>
                              {parseBalance(account.current_balance) < 0 && (
                                <Chip 
                                  icon={<WarningIcon />}
                                  label="Négatif" 
                                  size="small" 
                                  color="error"
                                />
                              )}
                            </Box>
                            <Typography 
                              variant="h5" 
                              fontWeight="bold"
                              sx={{ 
                                color: parseBalance(account.current_balance) >= 0 ? 'success.main' : 'error.main'
                              }}
                            >
                              {formatCurrency(parseBalance(account.current_balance))}
                            </Typography>
                          </Box>
                        </CardContent>
                      </Card>
                    </Grid>
                  ))}
              </Grid>
            </Grid>
          </Grid>
        </TabPanel>

        {/* Account Movements Tab */}
        <TabPanel value={tabValue} index={3}>
          <Grid container spacing={3}>
            {/* Filters Section */}
            <Grid item xs={12}>
              <Paper sx={{ p: 3, mb: 3 }} elevation={1}>
                <Typography variant="h6" gutterBottom>
                  Filtres et contrôles
                </Typography>
                <Grid container spacing={2} alignItems="center">
                  <Grid item xs={12} sm={6} md={3}>
                    <Autocomplete
                      options={allAccounts}
                      getOptionLabel={(option) => `${option.name} (${option.account_type})`}
                      value={selectedAccount}
                      onChange={(event, newValue) => setSelectedAccount(newValue)}
                      renderInput={(params) => (
                        <TextField 
                          {...params} 
                          label="Compte" 
                          size="small"
                          fullWidth
                        />
                      )}
                    />
                  </Grid>
                  <Grid item xs={12} sm={6} md={2}>
                    <TextField
                      label="Date début"
                      type="date"
                      size="small"
                      fullWidth
                      value={startDate}
                      onChange={(e) => setStartDate(e.target.value)}
                      InputLabelProps={{ shrink: true }}
                    />
                  </Grid>
                  <Grid item xs={12} sm={6} md={2}>
                    <TextField
                      label="Date fin"
                      type="date"
                      size="small"
                      fullWidth
                      value={endDate}
                      onChange={(e) => setEndDate(e.target.value)}
                      InputLabelProps={{ shrink: true }}
                    />
                  </Grid>
                  <Grid item xs={12} sm={6} md={2}>
                    <Autocomplete
                      options={[
                        { value: '', label: 'Tous les types' },
                        { value: 'client_payment', label: 'Règlement client' },
                        { value: 'supplier_payment', label: 'Règlement fournisseur' },
                        { value: 'transfer_in', label: 'Virement entrant' },
                        { value: 'transfer_out', label: 'Virement sortant' },
                        { value: 'cash_receipt', label: 'Encaissement' },
                        { value: 'cash_payment', label: 'Décaissement' },
                        { value: 'expense', label: 'Dépense' },
                        { value: 'sale', label: 'Vente' },
                        { value: 'purchase', label: 'Achat' },
                        { value: 'deposit', label: 'Dépôt' }
                      ]}
                      getOptionLabel={(option) => option.label}
                      value={[
                        { value: '', label: 'Tous les types' },
                        { value: 'client_payment', label: 'Règlement client' },
                        { value: 'supplier_payment', label: 'Règlement fournisseur' },
                        { value: 'transfer_in', label: 'Virement entrant' },
                        { value: 'transfer_out', label: 'Virement sortant' },
                        { value: 'cash_receipt', label: 'Encaissement' },
                        { value: 'cash_payment', label: 'Décaissement' },
                        { value: 'expense', label: 'Dépense' },
                        { value: 'sale', label: 'Vente' },
                        { value: 'purchase', label: 'Achat' },
                        { value: 'deposit', label: 'Dépôt' }
                      ].find(option => option.value === transactionTypeFilter) || { value: '', label: 'Tous les types' }}
                      isOptionEqualToValue={(option, value) => option.value === value.value}
                      onChange={(event, newValue) => setTransactionTypeFilter(newValue?.value || '')}
                      renderInput={(params) => (
                        <TextField 
                          {...params} 
                          label="Type" 
                          size="small"
                          fullWidth
                        />
                      )}
                    />
                  </Grid>
                </Grid>
              </Paper>
            </Grid>

            {/* Account Summary Cards */}
            {selectedAccount && (
              <Grid item xs={12}>
                <Grid container spacing={2}>
                  <Grid item xs={12} sm={6} md={3}>
                    <Card>
                      <CardContent>
                        <Typography variant="body2" color="text.secondary" gutterBottom>
                          Compte sélectionné
                        </Typography>
                        <Typography variant="h6" fontWeight="bold">
                          {selectedAccount.name}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          {selectedAccount.account_type}
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                  <Grid item xs={12} sm={6} md={3}>
                    <Card>
                      <CardContent>
                        <Typography variant="body2" color="text.secondary" gutterBottom>
                          Solde actuel
                        </Typography>
                        <Typography 
                          variant="h6" 
                          fontWeight="bold"
                          color={parseBalance(selectedAccount.current_balance) >= 0 ? 'success.main' : 'error.main'}
                        >
                          {formatCurrency(parseBalance(selectedAccount.current_balance))}
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                  <Grid item xs={12} sm={6} md={3}>
                    <Card>
                      <CardContent>
                        <Typography variant="body2" color="text.secondary" gutterBottom>
                          Total débits
                        </Typography>
                        <Typography variant="h6" fontWeight="bold" color="error.main">
                          {formatCurrency(accountMovements.reduce((sum, mov) => sum + parseBalance(mov.debit), 0))}
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                  <Grid item xs={12} sm={6} md={3}>
                    <Card>
                      <CardContent>
                        <Typography variant="body2" color="text.secondary" gutterBottom>
                          Total crédits
                        </Typography>
                        <Typography variant="h6" fontWeight="bold" color="success.main">
                          {formatCurrency(accountMovements.reduce((sum, mov) => sum + parseBalance(mov.credit), 0))}
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                </Grid>
              </Grid>
            )}

            {/* Movements Table */}
            <Grid item xs={12}>
              {error && (
                <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
                  {error}
                </Alert>
              )}

             <AccountMovementsTabs accountMovements={accountMovements} loadingMovements={loadingMovements} allAccounts={allAccounts} />

            </Grid>
          </Grid>
        </TabPanel>
      </StyledPaper>

      {/* Client Deposit Dialog */}
      <Dialog 
        open={showDepositModal} 
        onClose={() => setShowDepositModal(false)} 
        maxWidth="sm" 
        fullWidth
        PaperProps={{
          sx: { borderRadius: 2 }
        }}
      >
        <DialogTitle>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <AttachMoneyIcon sx={{ mr: 1, color: 'primary.main' }} />
            Nouveau dépôt client
          </Box>
        </DialogTitle>
        <Divider />
        <DialogContent>
          {loadingResources ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
              <CircularProgress />
            </Box>
          ) : (
            <Grid container spacing={2} sx={{ mt: 0.5 }}>
              {error && (
                <Grid item xs={12}>
                  <Alert severity="error" onClose={() => setError(null)}>
                    {error}
                  </Alert>
                </Grid>
              )}
              <Grid item xs={12}>
                <Autocomplete
                  options={clients}
                  getOptionLabel={(option) => option.name}
                  value={clients.find(c => c.id === newDeposit.client) || null}
                  isOptionEqualToValue={(option, value) => option.id === value.id}
                  onChange={(event, newValue) => {
                    setNewDeposit({
                      ...newDeposit,
                      client: newValue ? newValue.id : null,
                      account: newValue ? newValue.account || null : null
                    });
                  }}
                  renderInput={(params) => (
                    <TextField {...params}
                      label="Client"
                      variant="outlined"
                      fullWidth
                      required
                    />
                  )}
                  disabled={!!selectedClient}
                />
              </Grid>
              <Grid item xs={12}>
                <Autocomplete
                  options={accounts}
                  getOptionLabel={(option) => `${option.name} (${option.account_type})`}
                  value={selectedClient ? accounts.find(a => a.id === selectedClient.account) || null : accounts.find(a => a.id === newDeposit.account) || null}
                  isOptionEqualToValue={(option, value) => option.id === value.id}
                  onChange={(event, newValue) => {
                      setNewDeposit({...newDeposit, account: newValue ? newValue.id : null});
                  }}
                  renderInput={(params) => (
                    <TextField {...params}
                      label="Compte du client"
                      variant="outlined"
                      fullWidth
                      required
                    />
                  )}
                  disabled={!!selectedClient}
                />
              </Grid>
               <Grid item xs={12}>                
                <Autocomplete
                  options={paymentMethods}
                  getOptionLabel={(option) => option.name}
                  value={newDeposit.payment_method}
                  onChange={(event, newValue) => {
                    setNewDeposit({...newDeposit, payment_method: newValue});
                  }}
                  renderInput={(params) => (
                    <TextField {...params}
                      label="Méthode de paiement"
                      variant="outlined"
                      fullWidth
                      required
                    />
                  )}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <TextField
                  label="Montant"
                  type="text"
                  value={formatNumberDisplay(newDeposit.amount)}
                  onChange={(e) => {
                    const newValue = validateDecimalInput(e.target.value, newDeposit.amount);
                    setNewDeposit({...newDeposit, amount: newValue});
                  }}
                  fullWidth
                  required
                  error={newDeposit.amount <= 0}
                  helperText={getValidationError(newDeposit.amount, 'amount')}
                />
              </Grid>
              <Grid item xs={12} md={6}>
                <TextField
                  label="Date"
                  type="date"
                  value={newDeposit.date}
                  onChange={(e) => setNewDeposit({...newDeposit, date: e.target.value})}
                  fullWidth
                  required
                  InputLabelProps={{
                    shrink: true,
                  }}
                />
              </Grid>
              <Grid item xs={12}>
                <TextField
                  label="Description"
                  value={newDeposit.description}
                  onChange={(e) => setNewDeposit({...newDeposit, description: e.target.value})}
                  fullWidth
                  multiline
                  rows={2}
                />
              </Grid>
            </Grid>
          )}
        </DialogContent>
        <Divider />
        <DialogActions sx={{ px: 3, py: 2 }}>
          <Button 
            onClick={() => setShowDepositModal(false)}
            variant="outlined"
          >
            Annuler
          </Button>
          <Button 
            variant="contained" 
            onClick={handleCreateDeposit}
            disabled={loadingResources}
            startIcon={<AttachMoneyIcon />}
          >
            Créer le dépôt
          </Button>
        </DialogActions>
      </Dialog>

      {/* Payment Dialog */}
      <Dialog 
        open={showPaymentModal} 
        onClose={() => setShowPaymentModal(false)} 
        maxWidth="sm" 
        fullWidth
        PaperProps={{
          sx: { borderRadius: 2 }
        }}
      >
        <DialogTitle sx={{ borderBottom: 1, borderColor: 'divider', pb: 2, display: 'flex', alignItems: 'center' }}>
          <PaymentIcon sx={{ mr: 1, color: 'primary.main' }} />
          <Typography variant="h6" component="div">
            Paiement de vente
          </Typography>
        </DialogTitle>
        <DialogContent>
          {selectedSaleForPayment && (
            <Box sx={{ py: 2 }}>
              {selectedSaleForPayment.payment_status === 'paid' ? (
                <Alert severity="info" sx={{ mb: 3 }}>
                  <AlertTitle>Vente déjà payée</AlertTitle>
                  Cette vente a déjà été entièrement payée. Aucun paiement supplémentaire n'est nécessaire.
                </Alert>
              ) : null}
              
              {/* Sale information card */}
              <Paper 
                variant="outlined" 
                sx={{ p: 2, mb: 3, borderRadius: 1, borderColor: 'divider', backgroundColor: 'background.paper' }}
              >
                <Typography variant="h6" color="primary" gutterBottom sx={{ mb: 2, fontWeight: 'medium', borderBottom: 1, pb: 1, borderColor: 'divider' }}>
                  Informations de la vente
                </Typography>
                
                <Grid container spacing={2}>
                  <Grid item xs={6}>
                    <Typography variant="body2" color="text.secondary">
                      Référence
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium">
                      {selectedSaleForPayment.reference}
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={6}>
                    <Typography variant="body2" color="text.secondary">
                      Client
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium">
                      {selectedClient?.name || 'N/A'}
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <Divider sx={{ my: 1 }} />
                  </Grid>
                  
                  <Grid item xs={4}>
                    <Typography variant="body2" color="text.secondary">
                      Montant total
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium">
                      {formatCurrency(selectedSaleForPayment.total_amount)}
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={4}>
                    <Typography variant="body2" color="text.secondary">
                      Déjà payé
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium" color="success.main">
                      {formatCurrency(selectedSaleForPayment.paid_amount)}
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={4}>
                    <Typography variant="body2" color="text.secondary">
                      Montant restant
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium" color={selectedSaleForPayment.balance >  0 ? "error.main" : "success.main"}>
                      {formatCurrency(selectedSaleForPayment.payment_status === 'unpaid' && selectedSaleForPayment.balance === 0 
                        ? selectedSaleForPayment.total_amount 
                        : Math.max(0, selectedSaleForPayment.balance))}
                    </Typography>
                  </Grid>
                </Grid>
              </Paper>
              
              {/* Client account balance card */}
              <Paper 
                variant="outlined" 
                sx={{ 
                  p: 2, 
                  mb: 3, 
                  borderRadius: 1, 
                  borderColor: clientBalanceData && clientBalanceData.balance < 0 ? 'error.main' : 'divider',
                  backgroundColor: 'background.paper',
                  borderWidth: clientBalanceData && clientBalanceData.balance < 0 ? 2 : 1
                }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                  <AccountBalanceWalletIcon sx={{ mr: 1, color: clientBalanceData && clientBalanceData.balance >= 0 ? 'success.main' : 'error.main' }} />
                  <Typography variant="h6" color="primary" sx={{ fontWeight: 'medium' }}>
                    Compte client
                  </Typography>
                </Box>
                
                <Grid container alignItems="center" spacing={2}>
                  <Grid item xs={12} sm={6}>
                    <Typography variant="body2" color="text.secondary" gutterBottom>
                      Solde disponible
                    </Typography>
                    <Typography 
                      variant="h6" 
                      fontWeight="medium"
                      color={clientBalanceData && clientBalanceData.balance >= 0 ? 'success.main' : 'error.main'}
                    >
                      {clientBalanceData ? formatCurrency(clientBalanceData.balance) : 'Chargement...'}
                    </Typography>
                  </Grid>
                  
                  {(!clientBalanceData || clientBalanceData.balance <= 0) && (
                    <Grid item xs={12} sm={6}>
                      <Typography variant="caption" color="error" sx={{ display: 'flex', alignItems: 'center' }}>
                        <WarningIcon fontSize="small" sx={{ mr: 0.5 }} />
                        Solde insuffisant. Un paiement à crédit sera créé.
                      </Typography>
                    </Grid>
                  )}
                </Grid>
              </Paper>
              
              {/* Payment information */}
              <Typography variant="h6" color="primary" gutterBottom sx={{ mt: 3, mb: 2, fontWeight: 'medium' }}>
                Détails du paiement
              </Typography>
              
              <Grid container spacing={3}>
                <Grid item xs={12}>
                  <Autocomplete
                    options={allAccounts.filter(acc => acc.account_type !== 'client' && acc.account_type !== 'supplier')}
                    getOptionLabel={(option) => {
                      return option && option.name ? `${option.name} (${option.account_type})` : '';
                    }}
                    value={selectedCompanyAccount}
                    onChange={(event, newValue) => {
                      setSelectedCompanyAccount(newValue);
                      setCompanyAccountTouched(true);
                      setCompanyAccountError(null);
                    }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        label="Compte de l'entreprise à créditer"
                        variant="outlined"
                        fullWidth
                        required={companyAccountRequired}
                        error={companyAccountTouched && !selectedCompanyAccount}
                        helperText={companyAccountTouched && !selectedCompanyAccount ? companyAccountError : ''}
                      />
                    )}
                  />
                </Grid>
                <Grid item xs={12}>
                  <TextField
                    label="Montant du paiement"
                    type="text"
                    fullWidth
                    required
                    value={formatNumberDisplay(paymentAmount)}
                    onChange={(e) => {
                      const newValue = validateAmountInput(e.target.value, paymentAmount); // Remove maxValue restriction
                      setPaymentAmount(newValue);
                    }}
                    error={paymentAmount <= 0}
                    helperText={paymentAmount <= 0 ? "Le montant doit être supérieur à 0" : ""}
                    InputProps={{ 
                      startAdornment: (
                        <InputAdornment position="start">
                          <MoneyIcon color={
                            clientBalanceData && clientBalanceData.balance < paymentAmount 
                              ? "warning" 
                              : "primary"
                          } />
                        </InputAdornment>
                      )
                    }}
                    color={clientBalanceData && clientBalanceData.balance < paymentAmount ? "warning" : (
                      selectedSaleForPayment && paymentAmount < selectedSaleForPayment.total_amount ? "info" : "primary"
                    )}
                  />
                  
                  {/* Payment summary card with dynamic coloring based on payment type */}
                  <Box sx={{ mt: 3, mb: 2 }}>
                    <Paper 
                      variant="outlined" 
                      sx={{ 
                        p: 2,
                        borderRadius: 1,
                        borderColor: clientBalanceData && clientBalanceData.balance < paymentAmount 
                          ? 'warning.main' 
                          : (selectedSaleForPayment && paymentAmount < selectedSaleForPayment.total_amount 
                            ? 'info.main' 
                            : 'success.main'),
                        borderWidth: 2,
                        backgroundColor: clientBalanceData && clientBalanceData.balance < paymentAmount
                          ? 'rgba(237, 108, 2, 0.08)'  // warning light background
                          : (selectedSaleForPayment && paymentAmount < selectedSaleForPayment.total_amount
                            ? 'rgba(3, 169, 244, 0.08)'  // info light background
                            : 'rgba(46, 125, 50, 0.08)'),  // success light background
                        boxShadow: 1
                      }}
                    >
                      <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                        <Box sx={{ mr: 2, mt: 0.5 }}>
                          {clientBalanceData && clientBalanceData.balance < paymentAmount ? (
                            <WarningIcon fontSize="large" color="warning" />
                          ) : (
                            selectedSaleForPayment && paymentAmount < selectedSaleForPayment.total_amount ? (
                              <PaymentIcon fontSize="large" color="info" />
                            ) : (
                              <PaymentIcon fontSize="large" color="success" />
                            )
                          )}
                        </Box>
                        
                        <Box sx={{ flexGrow: 1 }}>
                          <Typography variant="h6" gutterBottom fontWeight="bold">
                            {clientBalanceData && clientBalanceData.balance < paymentAmount
                              ? "Paiement à crédit"
                              : (selectedSaleForPayment && paymentAmount < selectedSaleForPayment.total_amount
                                ? "Paiement partiel"
                                : "Paiement total")}
                          </Typography>
                          
                          {clientBalanceData && clientBalanceData.balance < paymentAmount ? (
                            <Typography variant="body2">
                              Ce paiement dépassera le solde disponible du client de {formatCurrency(paymentAmount - clientBalanceData.balance)} et créera un crédit.
                            </Typography>
                          ) : (
                            selectedSaleForPayment && paymentAmount < selectedSaleForPayment.total_amount ? (
                              <Typography variant="body2">
                                Vous effectuez un paiement partiel de {formatCurrency(paymentAmount)}. Un montant de {formatCurrency(selectedSaleForPayment.balance - paymentAmount)} restera à payer.
                                Le statut de la vente sera mis à jour en "Partiellement payé".
                              </Typography>
                            ) : (
                              <Typography variant="body2">
                                Vous effectuez le paiement total de cette vente d'un montant de {formatCurrency(paymentAmount)}.
                                Le statut de la vente sera mis à jour en "Payé".
                              </Typography>
                            )
                          )}
                          
                          {/* Show payment amount breakdown */}
                          <Grid container spacing={2} sx={{ mt: 1 }}>
                            <Grid item xs={6} sm={4}>
                              <Typography variant="caption" color="text.secondary">Montant du paiement</Typography>
                              <Typography variant="subtitle1" fontWeight="medium">
                                {formatCurrency(paymentAmount)}
                              </Typography>
                            </Grid>
                            
                            <Grid item xs={6} sm={4}>
                              <Typography variant="caption" color="text.secondary">Solde client utilisé</Typography>
                              <Typography variant="subtitle1" fontWeight="medium">
                                {clientBalanceData 
                                  ? formatCurrency(Math.min(clientBalanceData.balance, paymentAmount))
                                  : "Chargement..."}
                              </Typography>
                            </Grid>
                            
                            {clientBalanceData && clientBalanceData.balance < paymentAmount && (
                              <Grid item xs={6} sm={4}>
                                <Typography variant="caption" color="error.main">Montant à crédit</Typography>
                                <Typography variant="subtitle1" fontWeight="medium" color="error.main">
                                  {formatCurrency(paymentAmount - clientBalanceData.balance)}
                                </Typography>
                              </Grid>
                            )}
                          </Grid>
                        </Box>
                      </Box>
                    </Paper>
                  </Box>
                </Grid>
                
                <Grid item xs={12}>
                  <TextField
                    label="Description"
                    fullWidth
                    multiline
                    rows={2}
                    value={paymentDescription}
                    onChange={(e) => setPaymentDescription(e.target.value)}
                    placeholder="Description du paiement"
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <ReceiptIcon color="action" />
                        </InputAdornment>
                      ),
                    }}
                    helperText="Ajoutez une description facultative pour ce paiement"
                  />
                </Grid>
              </Grid>
            </Box>
          )}
        </DialogContent>
        <Divider />
        <DialogActions sx={{ px: 3, py: 2, justifyContent: 'space-between' }}>
          <Button 
            onClick={() => setShowPaymentModal(false)}
            variant="outlined"
            startIcon={<ArrowBackIcon />}
          >
            Annuler
          </Button>
          <Button
            variant="contained"
            color={clientBalanceData && clientBalanceData.balance < paymentAmount 
              ? "warning" 
              : (selectedSaleForPayment && paymentAmount < selectedSaleForPayment.total_amount 
                ? "info" 
                : "primary")}
            onClick={handlePayFromAccount}
            disabled={
              processingPayment || 
              !selectedSaleForPayment || 
              paymentAmount <= 0 ||
              (selectedSaleForPayment && selectedSaleForPayment.payment_status === 'paid') // Disable if already paid
            }
            startIcon={processingPayment ? <CircularProgress size={20} /> : <PaymentIcon />}
            sx={{ 
              fontWeight: 'medium',
              minWidth: '200px',
              px: 3
            }}
          >
            {processingPayment ? 'Traitement...' : (
              !selectedSaleForPayment ? 'Effectuer le paiement' : (
                selectedSaleForPayment.payment_status === 'paid' ? 
                'Vente déjà payée' : (
                  // First check if it's a partial payment - the amount is less than the total
                  paymentAmount > 0 && paymentAmount < selectedSaleForPayment.total_amount ?
                  'Effectuer un paiement partiel' : (
                    // Then check if it's a credit payment - client balance is less than payment amount
                    clientBalanceData && clientBalanceData.balance < paymentAmount ? 
                    'Effectuer le paiement à crédit' : 'Effectuer le paiement total'
                  )
                )
              )
            )}
          </Button>
        </DialogActions>      
        </Dialog>

      {/* Supplier Payment Dialog */}
      <Dialog 
        open={showSupplierPaymentModal} 
        onClose={() => setShowSupplierPaymentModal(false)} 
        maxWidth="sm" 
        fullWidth
        PaperProps={{
          sx: { borderRadius: 2 }
        }}
      >
        <DialogTitle sx={{ borderBottom: 1, borderColor: 'divider', pb: 2, display: 'flex', alignItems: 'center' }}>
          <PaymentIcon sx={{ mr: 1, color: 'warning.main' }} />
          <Typography variant="h6" component="div">
            Paiement fournisseur
          </Typography>
        </DialogTitle>
        <DialogContent>
          {selectedSupplyForPayment && (
            <Box sx={{ py: 2 }}>
              {selectedSupplyForPayment.payment_status === 'paid' ? (
                <Alert severity="info" sx={{ mb: 3 }}>
                  <AlertTitle>Approvisionnement déjà payé</AlertTitle>
                  Cet approvisionnement a déjà été entièrement payé. Aucun paiement supplémentaire n'est nécessaire.
                </Alert>
              ) : null}
              
              {/* Supply information card */}
              <Paper 
                variant="outlined" 
                sx={{ p: 2, mb: 3, borderRadius: 1, borderColor: 'divider', backgroundColor: 'background.paper' }}
              >
                <Typography variant="h6" color="warning.main" gutterBottom sx={{ mb: 2, fontWeight: 'medium', borderBottom: 1, pb: 1, borderColor: 'divider' }}>
                  Informations de l'approvisionnement
                </Typography>
                
                <Grid container spacing={2}>
                  <Grid item xs={6}>
                    <Typography variant="body2" color="text.secondary">
                      Référence
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium">
                      {selectedSupplyForPayment.reference}
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={6}>
                    <Typography variant="body2" color="text.secondary">
                      Fournisseur
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium">
                      {selectedSupplier?.name || 'N/A'}
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={4}>
                    <Typography variant="body2" color="text.secondary">
                      Montant total
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium">
                      {formatCurrency(selectedSupplyForPayment.total_amount)}
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={4}>
                    <Typography variant="body2" color="text.secondary">
                      Montant payé
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="medium" color="success.main">
                      {formatCurrency(selectedSupplyForPayment.paid_amount)}
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={4}>
                    <Typography variant="body2" color="text.secondary">
                      Restant à payer
                    </Typography>
                    <Typography variant="subtitle1" fontWeight="bold" color="error.main">
                      {formatCurrency(selectedSupplyForPayment.remaining_amount)}
                    </Typography>
                  </Grid>
                </Grid>
              </Paper>

              <Grid container spacing={2}>
                <Grid item xs={12}>
                  <Autocomplete
                    options={allAccounts.filter(acc => acc.account_type !== 'client' && acc.account_type !== 'supplier')}
                    getOptionLabel={(option) => `${option.name} - Solde: ${formatCurrency(parseBalance(option.current_balance))}`}
                    value={selectedSupplierCompanyAccount}
                    onChange={(event, newValue) => {
                      setSelectedSupplierCompanyAccount(newValue);
                    }}
                    renderInput={(params) => (
                      <TextField 
                        {...params}
                        label="Compte de l'entreprise" 
                        variant="outlined"
                        required
                        helperText={
                          selectedSupplierCompanyAccount && parseBalance(selectedSupplierCompanyAccount.current_balance) < supplierPaymentAmount
                            ? `⚠️ Attention: Ce paiement créera un solde négatif (${formatCurrency(parseBalance(selectedSupplierCompanyAccount.current_balance) - supplierPaymentAmount)})`
                            : "Sélectionnez le compte de l'entreprise pour effectuer le paiement"
                        }
                        InputLabelProps={{
                          sx: selectedSupplierCompanyAccount && parseBalance(selectedSupplierCompanyAccount.current_balance) < supplierPaymentAmount 
                            ? { color: 'warning.main' } 
                            : undefined
                        }}
                      />
                    )}
                    renderOption={(props, option) => (
                      <li {...props}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
                          <Typography>{option.name}</Typography>
                          <Chip 
                            label={formatCurrency(parseBalance(option.current_balance))} 
                            size="small"
                            color={parseBalance(option.current_balance) >= supplierPaymentAmount ? 'success' : 'warning'}
                            icon={parseBalance(option.current_balance) < supplierPaymentAmount ? <WarningIcon fontSize="small" /> : undefined}
                            sx={{ fontWeight: 'bold' }}
                          />
                        </Box>
                      </li>
                    )}
                  />
                </Grid>

                <Grid item xs={12}>
                  <TextField
                    label="Montant du paiement"
                    type="text"
                    fullWidth
                    value={formatNumberDisplay(supplierPaymentAmount)}
                    onChange={(e) => {
                      const newValue = validateDecimalInput(e.target.value, supplierPaymentAmount);
                      setSupplierPaymentAmount(newValue);
                    }}
                    error={
                      supplierPaymentAmount <= 0 || 
                      supplierPaymentAmount > selectedSupplyForPayment.remaining_amount
                    }
                    helperText={
                      supplierPaymentAmount <= 0 
                        ? 'Le montant doit être supérieur à zéro' 
                        : supplierPaymentAmount > selectedSupplyForPayment.remaining_amount
                        ? 'Le montant ne peut pas dépasser le solde restant'
                        : selectedSupplierCompanyAccount && parseBalance(selectedSupplierCompanyAccount.current_balance) < supplierPaymentAmount
                        ? `⚠️ Attention: Solde insuffisant (${formatCurrency(parseBalance(selectedSupplierCompanyAccount.current_balance))} disponible) - Le compte sera négatif`
                        : `Solde restant: ${formatCurrency(selectedSupplyForPayment.remaining_amount)}`
                    }
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <AttachMoneyIcon fontSize="small" />
                        </InputAdornment>
                      ),
                    }}
                  />
                </Grid>

                <Grid item xs={12}>
                  <TextField
                    label="Description"
                    fullWidth
                    multiline
                    rows={2}
                    value={supplierPaymentDescription}
                    onChange={(e) => setSupplierPaymentDescription(e.target.value)}
                    placeholder="Description du paiement"
                  />
                </Grid>
              </Grid>
            </Box>
          )}
        </DialogContent>
        <Divider />
        <DialogActions sx={{ px: 3, py: 2 }}>
          <Button 
            onClick={() => setShowSupplierPaymentModal(false)}
            variant="outlined"
            startIcon={<ArrowBackIcon />}
          >
            Annuler
          </Button>
          <Button
            variant="contained"
            color="warning"
            onClick={handleSupplierPayment}
            disabled={
              processingSupplierPayment || 
              !selectedSupplyForPayment || 
              !selectedSupplierCompanyAccount ||
              supplierPaymentAmount <= 0 ||
              supplierPaymentAmount > (selectedSupplyForPayment?.remaining_amount || 0) ||
              (selectedSupplyForPayment && selectedSupplyForPayment.payment_status === 'paid')
            }
            startIcon={processingSupplierPayment ? <CircularProgress size={20} /> : <PaymentIcon />}
            sx={{ 
              fontWeight: 'medium',
              minWidth: '200px',
              px: 3
            }}
          >
            {processingSupplierPayment ? 'Traitement...' : 'Effectuer le paiement'}
          </Button>
        </DialogActions>      
      </Dialog>

      {/* Success Snackbar */}
      <Snackbar
        open={showSuccessSnackbar}
        autoHideDuration={6000}
        onClose={() => setShowSuccessSnackbar(false)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert 
          onClose={() => setShowSuccessSnackbar(false)} 
          severity="success"
          variant="filled"
          sx={{ width: '100%' }}
        >
          {successMessage}
        </Alert>
      </Snackbar>
    </Box>
    </PermissionGuard>
  );
};

export default Treasury;